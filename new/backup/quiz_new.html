<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>互动测验页面</title>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Load the quiz data JavaScript file -->
    <script src="quiz_data.js"></script>
    <style>
        /* Global box-sizing for consistent layout */
        *, *::before, *::after {
            box-sizing: border-box;
        }

        /* Ensure html and body take full viewport height */
        html, body {
            height: 100%; /* Ensure html takes full height */
            margin: 0;
            padding: 0;
            overflow: hidden; /* Keep original overflow: hidden on body */
        }

        /* General body styling for black and green theme */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a1a1a; /* Dark background */
            color: #e0e0e0; /* Light text color */
            display: flex; /* Use flexbox for main layout */
            height: 100vh; /* Full viewport height */
        }

        /* Custom Scrollbar Styles for WebKit browsers (Chrome, Safari, Edge) */
        ::-webkit-scrollbar {
            width: 8px; /* Vertical scrollbar width */
            height: 8px; /* Horizontal scrollbar height */
        }

        ::-webkit-scrollbar-track {
            background: #2a2a2a; /* Scrollbar track background */
            border-radius: 10px; /* Rounded corners for the track */
        }

        ::-webkit-scrollbar-thumb {
            background: #555; /* Scrollbar thumb color */
            border-radius: 10px; /* Rounded corners for the thumb */
            border: 2px solid #2a2a2a; /* Border around the thumb, matching track background */
        }

        ::-webkit-scrollbar-thumb:hover {
            background: #777; /* Scrollbar thumb color on hover */
        }

        /* Custom Scrollbar Styles for Firefox */
        html {
            scrollbar-width: thin; /* "auto" or "thin" */
            scrollbar-color: #555 #2a2a2a; /* thumb color track color */
        }


        /* Main container for the quiz layout */
        .quiz-container {
            display: flex;
            width: 100%;
            height: 100%;
        }

        /* Sidebar Toggle Button - Moved outside the sidebar again, fixed */
        /* This button will only be used to SHOW the sidebar when it's hidden */
        #showSidebarIconContainer {
            background-color: #4CAF50; /* Green button */
            color: white;
            border: none;
            border-radius: 8px;
            padding: 10px 15px; /* Larger padding for prominent fixed button */
            cursor: pointer;
            font-size: 16px; /* Larger font size */
            position: fixed; /* Keep it fixed */
            left: 20px; /* Fixed position from left */
            top: 20px; /* Fixed position from top */
            z-index: 1002; /* Ensure it's above other content */
            transition: background-color 0.3s ease, transform 0.2s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            display: none; /* Initially hidden */
            align-items: center; /* Center icon vertically */
            justify-content: center; /* Center icon horizontally */
            width: 40px; /* Make it a square button */
            height: 40px;
        }

        #showSidebarIconContainer:hover {
            background-color: #45a049;
            transform: translateY(-2px);
        }
        
        #showSidebarIconContainer i {
            font-size: 20px; /* Adjust icon size within the button */
        }


        /* Left sidebar navigation */
        .sidebar {
            width: 320px; /* Increased default width for better text display */
            background-color: #2a2a2a; /* Slightly lighter dark for sidebar */
            padding: 20px;
            box-shadow: 2px 0 5px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease-in-out; /* Smooth transition for hide/show */
            flex-shrink: 0; /* Prevent shrinking */
            display: flex;
            flex-direction: column; /* Arrange header and content vertically */
            position: fixed; /* Fixed to prevent content jumping */
            top: 0;
            left: 0;
            height: 100%; /* Make sidebar take 100% height of its parent (html/body flex context) */
            border-right: 1px solid #333;
            z-index: 1000;
            transform: translateX(0); /* Default position */
        }

        .sidebar.hidden {
            transform: translateX(-100%); /* Move off-screen to the left */
        }

        .sidebar-header {
            display: flex;
            flex-direction: column; /* Stack h2 and select vertically */
            align-items: flex-start; /* Align content to start */
            margin-bottom: 15px; /* Space between header and list */
            flex-shrink: 0; /* Prevent header from shrinking */
            padding-left: 0; /* No left padding here, elements align to container edge */
            width: 100%; /* Take full width */
        }

        .sidebar-header h2 {
            margin: 0 0 10px 0; /* Adjust margin for h2 inside header */
            font-size: 20px; /* Adjust h2 font size if needed */
            color: #4CAF50;
            width: 100%; /* Take full width of its parent */
            display: flex; /* Make h2 a flex container for text and icon */
            justify-content: space-between; /* Push icon to the right */
            align-items: center; /* Vertically align icon with text */
        }

        /* Icon for hiding sidebar, now within h2 */
        #hideSidebarIcon {
            cursor: pointer;
            font-size: 20px;
            color: #e0e0e0;
            margin-left: 10px; /* Space from "测验导航" text */
            transition: color 0.2s ease;
        }

        #hideSidebarIcon:hover {
            color: #4CAF50;
        }

        /* Custom Dropdown Styles */
        .custom-dropdown {
            position: relative; /* For dropdown content positioning */
            width: 100%;
            margin-bottom: 15px;
        }

        .dropdown-toggle {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid #555;
            background-color: #3a3a3a;
            color: #e0e0e0;
            font-size: 16px;
            cursor: pointer;
            transition: border-color 0.3s ease, box-shadow 0.3s ease;
        }

        .dropdown-toggle:hover {
            border-color: #4CAF50;
        }

        .dropdown-toggle.active {
            border-color: #4CAF50;
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.5);
        }

        .dropdown-menu {
            position: absolute;
            top: 100%; /* Position below the toggle button */
            left: 0;
            width: 100%;
            background-color: #3a3a3a; /* Dark background for dropdown menu */
            border: 1px solid #555;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
            list-style: none;
            padding: 0;
            margin: 5px 0 0 0; /* Space between toggle and menu */
            z-index: 1001; /* Ensure it's above other content */
            display: none; /* Hidden by default */
            max-height: 200px; /* Max height for scrollable menu */
            overflow-y: auto; /* Enable scrolling for menu items */
        }

        .dropdown-menu.show {
            display: block;
        }

        .dropdown-menu li {
            padding: 10px 15px;
            color: #e0e0e0;
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
            border-bottom: 1px solid #4a4a4a; /* Add bottom border for separation */
        }

        .dropdown-menu li:last-child {
            border-bottom: none; /* No border for the last item */
        }

        .dropdown-menu li:hover {
            background-color: #4CAF50; /* Green on hover */
            color: white;
        }

        .dropdown-arrow {
            transition: transform 0.2s ease;
        }

        .dropdown-toggle.active .dropdown-arrow {
            transform: rotate(180deg);
        }


        .sidebar-content {
            flex-grow: 1; /* Allows list to take remaining space */
            padding: 0; /* Reset padding, as sidebar itself has it */
            display: flex; /* For controlling the list within it */
            flex-direction: column;
            padding-right: 10px; /* Add some padding to prevent scrollbar overlapping text */
            min-height: 0; /* Critical for nested flex containers to allow scrolling children */
        }

        .quiz-nav {
            list-style: none;
            padding: 0;
            margin: 0;
            flex-grow: 1; /* Allow the list to expand */
            overflow-y: auto; /* Scroll for nav list itself */
        }

        .quiz-nav li {
            padding: 10px 15px;
            margin-bottom: 8px;
            background-color: #3a3a3a; /* Darker background for nav items */
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.3s ease, color 0.3s ease;
            white-space: nowrap; /* Prevent text wrapping */
            overflow: hidden; /* Hide overflow text */
            text-overflow: ellipsis; /* Add ellipsis for long titles */
        }

        .quiz-nav li:hover {
            background-color: #4CAF50; /* Green on hover */
            color: white;
        }

        .quiz-nav li.active {
            background-color: #4CAF50; /* Active quiz in green */
            color: white;
            font-weight: bold;
        }

        .quiz-nav li.completed {
            background-color: #28a745; /* Darker green for completed quizzes */
            color: #ffffff;
            opacity: 0.8;
        }

        /* Right main content area */
        .main-content {
            flex-grow: 1; /* Takes remaining space */
            display: flex; /* Use flexbox to center inner wrapper */
            flex-direction: column; /* Keep column to stack the inner wrapper vertically (if needed) or just for flex properties */
            padding: 20px; /* Padding for main content */
            position: relative;
            overflow-y: auto; /* Main scroll for this area if content overflows */
            margin-left: 340px; /* Adjusted margin for new sidebar width (320px + 20px buffer) */
            transition: margin-left 0.3s ease-in-out; /* Keep for smooth transition */
            align-items: center; /* Center content horizontally */
            justify-content: flex-start; /* Align content to the top */
        }

        /* When sidebar is hidden, adjust main content margin-left to allow centering */
        body.sidebar-hidden .main-content {
            margin-left: 20px; /* Reduced margin when sidebar is hidden, aligns with left side */
        }


        /* NEW INNER WRAPPER for horizontal layout and max-width/centering */
        .main-content-inner-wrapper {
            display: flex;
            flex-direction: row; /* Horizontal layout for question and answers */
            gap: 20px; /* Space between question panel and interaction panel */
            width: 100%; /* Take full width of parent up to max-width */
            max-width: 1800px; /* Overall max width for the quiz content area */
            align-items: flex-start; /* Align children to their top */
            flex-wrap: wrap; /* Allow wrapping on smaller screens */
            height: 100%; /* Make it take full height available from main-content's content box */
        }

        /* Left Panel: Question Text */
        .quiz-content-panel {
            flex: 2.5; /* Adjusted proportion to be larger */
            min-width: 450px; /* Minimum width for the question text panel */
            background-color: #2a2a2a;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            display: flex; /* Use flex for direct children: h2, quiz-type, question-text-scroll-wrapper */
            flex-direction: column;
            max-height: calc(100% - 0px); /* 100% of parent's height (main-content-inner-wrapper) */
        }

        /* Right Panel: Controls and Options */
        .quiz-interaction-panel {
            flex: 3; /* Adjusted proportion to be larger */
            min-width: 400px; /* Increased minimum width for interaction panel */
            display: flex;
            flex-direction: column; /* Stack controls and options vertically */
            gap: 20px; /* Gap between controls and options */
            background-color: #2a2a2a;
            padding: 25px;
            border-radius: 12px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            max-height: calc(100% - 0px); /* 100% of parent's height (main-content-inner-wrapper) */
        }

        /* Styles for content within the left question panel */
        #quiz-title { /* Renamed from #question-container h2 for direct targeting */
            font-size: 24px;
            color: #4CAF50; /* Green for question title */
            margin-bottom: 10px;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
            flex-shrink: 0; /* Prevent shrinking when content scrolls */
        }

        #quiz-type {
            font-size: 16px;
            color: #a0a0a0;
            margin-bottom: 15px;
            flex-shrink: 0; /* Prevent shrinking when content scrolls */
        }
        
        /* New wrapper for the scrollable question text */
        #question-text-scroll-wrapper {
            flex-grow: 1; /* Allows content to take available space */
            overflow-y: auto; /* Scroll for question text content */
            padding-right: 10px; /* Add some padding to prevent text from touching scrollbar */
            display: flex; /* Ensure its child `p` behaves well within it */
            flex-direction: column;
            gap: 15px; /* Spacing for consistency if future elements are added here */
        }

        .question-content {
            font-size: 18px;
            line-height: 1.6;
            white-space: pre-wrap; /* Preserve line breaks from content */
            margin-bottom: 0; /* No margin-bottom here, gap from parent handles it */
            color: #e0e0e0;
            flex-grow: 1; /* Allows content to grow and take space within the scroll wrapper */
        }

        /* Highlighted question number within the main content */
        .question-content .question-num-in-text {
            color: #87CEEB; /* Light blue for highlighting */
            text-decoration: underline;
            font-weight: bold;
            cursor: pointer; /* Indicate it's clickable */
            background-color: rgba(69, 160, 73, 0.2); /* Subtle green background for emphasis */
            padding: 2px 4px;
            border-radius: 4px;
            display: inline-block; /* Ensure padding and background apply correctly */
        }

        .question-content .question-num-in-text:hover {
            color: #ADD8E6; /* Slightly lighter blue on hover */
        }

        /* Media container styles */
        .question-media-container {
            margin-bottom: 15px;
            border-radius: 8px;
            overflow: hidden; /* Ensures video corners are rounded */
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            flex-shrink: 0; /* Prevent shrinking */
        }

        .question-media-video {
            width: 100%;
            height: auto; /* Maintain aspect ratio */
            display: block; /* Remove extra space below video */
            border-radius: 8px; /* Apply rounded corners to video */
        }


        /* Controls remain the same, just moved into quiz-interaction-panel */
        .controls {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping for smaller screens */
            gap: 15px;
            align-items: center;
            padding-top: 0; /* No top padding, parent panel handles it */
            border-top: none; /* No top border, parent panel handles it */
        }

        .control-button {
            background-color: #4CAF50; /* Green button */
            color: white;
            border: none;
            border-radius: 8px;
            padding: 12px 25px;
            cursor: pointer;
            font-size: 18px;
            transition: background-color 0.3s ease, transform 0.2s ease, box-shadow 0.3s ease;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
            flex-shrink: 0; /* Prevent shrinking */
        }

        .control-button:hover:not(:disabled) {
            background-color: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 10px rgba(0, 0, 0, 0.3);
        }

        .control-button:disabled {
            background-color: #555;
            cursor: not-allowed;
            opacity: 0.6;
        }

        .timer-display, .score-display {
            font-size: 18px;
            color: #4CAF50; /* Green for timer/score */
            background-color: #3a3a3a;
            padding: 10px 20px;
            border-radius: 8px;
            min-width: 150px;
            text-align: center;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        /* Options container now specifically handles overflow for its content */
        .options-container {
            flex-grow: 1; /* Takes remaining vertical space in quiz-interaction-panel */
            overflow-y: auto; /* Critical for scrolling options */
            min-height: 100px; /* Minimum height for options area */
            /* No specific background/padding/shadow here, inherited from parent quiz-interaction-panel */
            display: flex; /* Keep flex for inner question blocks */
            flex-direction: column;
            gap: 15px; /* Space between question blocks */
            padding: 0; /* No padding, parent panel handles it */
        }

        /* Styling for each individual sub-question block */
        .question-block {
            background-color: #3a3a3a;
            padding: 15px;
            border-radius: 8px;
            border: 1px solid transparent; /* Default border */
            transition: border-color 0.3s ease;
        }

        .question-sub-title {
            font-weight: bold;
            font-size: 1.1em;
            margin-bottom: 10px;
            color: #87CEEB; /* Light blue for question number */
        }

        /* Styles for single and multi-choice options */
        .choices-wrapper {
            display: grid; /* Changed to grid for better column control */
            grid-template-columns: repeat(4, minmax(0, 1fr)); /* 4 equal width columns */
            gap: 10px; /* Space between choices */
            align-items: stretch; /* Make all choice items in a row the same height */
            box-sizing: border-box; /* Ensure padding and border are included in width calculation */
        }

        /* Styling for each individual choice (A, B, C, D) */
        .choice-item {
            background-color: #444; /* Slightly lighter than question-block */
            padding: 12px 15px;
            border-radius: 6px;
            cursor: pointer;
            transition: background-color 0.3s ease, border-color 0.3s ease;
            border: 1px solid #555;
            display: flex; /* For aligning A. B. C. D. */
            align-items: center;
            font-size: 16px;
            box-sizing: border-box; /* Include padding and border in the width */
            white-space: nowrap; /* Prevent text wrapping inside choice item */
            overflow: hidden; /* Hide overflow text */
            text-overflow: ellipsis; /* Add ellipsis for long text */
        }

        @media (max-width: 1100px) { /* Adjusted breakpoint for 3 items per row on slightly smaller screens */
            .choices-wrapper {
                grid-template-columns: repeat(3, minmax(0, 1fr)); /* 3 equal width columns */
            }
        }

        @media (max-width: 900px) { /* Adjusted breakpoint for 2 items per row */
            .choices-wrapper {
                grid-template-columns: repeat(2, minmax(0, 1fr)); /* 2 equal width columns */
            }
        }

        @media (max-width: 700px) { /* Adjusted breakpoint for 1 item per row */
            .choices-wrapper {
                grid-template-columns: repeat(1, minmax(0, 1fr)); /* 1 equal width column */
            }
        }


        .choice-item:hover:not(.disabled):not(.selected-choice):not(.correct-choice):not(.incorrect-choice) {
            background-color: #555;
            border-color: #4CAF50;
        }

        /* Classes for selected, correct, incorrect choices */
        .choice-item.selected-choice {
            background-color: #4CAF50; /* Green for selected */
            border-color: #32CD32;
            color: white;
        }
        .choice-item.correct-choice {
            background-color: #28a745; /* Darker green for correct */
            border-color: #28a745;
            color: white;
            box-shadow: 0 0 8px rgba(40, 167, 69, 0.5);
        }
        .choice-item.incorrect-choice {
            background-color: #dc3545; /* Red for incorrect */
            border-color: #dc3545;
            color: white;
            box-shadow: 0 0 8px rgba(220, 53, 69, 0.5);
        }
        .choice-item.disabled {
            cursor: not-allowed;
            opacity: 0.7;
            pointer-events: none; /* Prevent clicks when disabled */
        }

        /* Styling for individual question explanations */
        .question-explanation {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 1px dashed #555;
            font-size: 15px;
            line-height: 1.5;
            color: #c0c0c0;
        }
        .question-explanation .your-answer {
            font-weight: bold;
            color: #87CEEB; /* Light blue for user's answer */
        }
        .question-explanation .correct-answer {
            font-weight: bold;
            color: #28a745; /* Dark green for correct answer */
        }
        .explanation-icon {
            margin-right: 8px; /* Space between icon and text */
            font-size: 1.2em; /* Slightly larger icon */
            vertical-align: middle; /* Align icon vertically with text */
        }


        /* --- New Styles for New Question Types --- */

        /* Fill-in-blank input */
        .fill-in-blank-container {
            display: flex;
            flex-wrap: wrap; /* Allow wrapping for long sentences */
            gap: 5px; /* Small gap between text parts and inputs */
            align-items: baseline; /* Align text and inputs on the same baseline */
        }

        .fill-in-blank-input {
            padding: 8px 10px;
            border-radius: 6px;
            border: 1px solid #555;
            background-color: #3a3a3a;
            color: #e0e0e0;
            font-size: 16px;
            box-sizing: border-box;
            min-width: 100px; /* Minimum width for input fields */
            max-width: 200px; /* Maximum width for input fields */
            flex-grow: 1; /* Allow inputs to grow if space available */
        }
        .fill-in-blank-input:focus {
            outline: none;
            border-color: #4CAF50;
            box-shadow: 0 0 0 2px rgba(76, 175, 80, 0.5);
        }
        .fill-in-blank-input.correct {
            border-color: #28a745;
            background-color: rgba(40, 167, 69, 0.2);
        }
        .fill-in-blank-input.incorrect {
            border-color: #dc3545;
            background-color: rgba(220, 53, 69, 0.2);
        }
        .fill-in-blank-text-part {
            white-space: pre-wrap; /* Preserve spaces and line breaks within text parts */
            line-height: 1.6;
        }


        /* Matching question styles */
        .matching-container {
            display: flex;
            justify-content: space-around;
            gap: 20px;
            margin-top: 10px;
        }

        .matching-column {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 8px;
            min-width: 150px; /* Ensure columns don't collapse too much */
        }

        .matching-item {
            background-color: #444;
            padding: 10px 15px;
            border-radius: 6px;
            cursor: grab; /* Indicate draggable */
            border: 1px solid #555;
            transition: background-color 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
            text-align: center;
        }

        .matching-item:hover:not(.disabled):not(.matching-selected-left):not(.matching-selected-right) {
            background-color: #555;
            border-color: #4CAF50;
        }

        /* Specific states for matching items */
        .matching-item.dragging {
            opacity: 0.5; /* Visual feedback for dragging */
            border: 2px dashed #4CAF50;
            cursor: grabbing;
        }

        .matching-item.drag-over {
            border: 2px dashed #87CEEB; /* Highlight drop target */
            box-shadow: 0 0 10px rgba(135, 206, 235, 0.7);
        }

        .matching-item.matching-selected-left {
            background-color: #87CEEB; /* Light blue for selected left item */
            border-color: #4A90E2;
            color: #1a1a1a;
            font-weight: bold;
        }

        .matching-item.matching-selected-right {
            background-color: #F7B84B; /* Orange for selected right item */
            border-color: #E2A03A;
            color: #1a1a1a;
            font-weight: bold;
        }

        .matching-item.matching-connected {
            background-color: #28a745; /* Green for correctly connected pairs */
            border-color: #28a745;
            color: white;
            opacity: 0.8;
            pointer-events: none; /* Disable further clicks on connected items */
        }

        .matching-item.matching-incorrect {
            background-color: #dc3545; /* Red for incorrectly connected pairs */
            border-color: #dc3545;
            color: white;
            opacity: 0.8;
            pointer-events: none;
        }

        /* Explanation specific to matching */
        .question-explanation .matching-explanation-pair {
            display: flex;
            justify-content: space-between;
            background-color: #4a4a4a;
            padding: 8px 12px;
            border-radius: 4px;
            margin-bottom: 5px;
            font-size: 14px;
        }
        .question-explanation .matching-explanation-pair.correct {
            border-left: 4px solid #28a745;
        }
        .question-explanation .matching-explanation-pair.incorrect {
            border-left: 4px solid #dc3545;
        }
        .question-explanation .matching-explanation-pair .left-side {
            color: #87CEEB;
            font-weight: bold;
        }
        .question-explanation .matching-explanation-pair .right-side {
            color: #F7B84B;
            font-weight: bold;
        }

        /* New styles for user-matched pairs display */
        .matching-user-pairs-display {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px dashed #555;
        }

        .matching-user-pairs-display h4 {
            color: #4CAF50;
            margin-bottom: 10px;
            font-size: 1.1em;
        }

        .matched-pair-item-display {
            background-color: #3a3a3a;
            padding: 8px 12px;
            border-radius: 6px;
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border: 1px solid #555;
            font-size: 15px;
            position: relative; /* For the remove button */
        }

        .matched-pair-item-display span {
            font-weight: bold;
        }

        .matched-pair-item-display .left-display {
            color: #87CEEB;
        }

        .matched-pair-item-display .right-display {
            color: #F7B84B;
        }

        .matched-pair-remove-btn {
            background-color: #dc3545;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            font-size: 12px;
            line-height: 1;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            transition: background-color 0.2s ease;
        }

        .matched-pair-remove-btn:hover {
            background-color: #c82333;
        }


        /* Responsive design */
        @media (max-width: 1024px) { /* Adjust breakpoint for column layout */
            .main-content-inner-wrapper {
                flex-direction: column; /* Stack panels vertically on smaller screens */
                max-width: 700px; /* Adjust overall max-width for stacked panels */
                width: 100%;
                height: auto; /* Allow height to adjust naturally when stacked */
            }

            .quiz-content-panel,
            .quiz-interaction-panel {
                max-height: none; /* Allow natural height when stacked */
                flex: none; /* Remove flex proportions when stacked */
                width: 100%; /* Take full width when stacked */
                min-width: unset; /* Remove min-width constraints */
            }

            /* Adjust options-container max-height when stacked */
            .options-container {
                max-height: 400px; /* Example fixed max-height when stacked, allowing its own scroll */
            }
            .matching-container {
                flex-direction: column; /* Stack matching columns vertically */
            }
            .matching-column {
                min-width: unset;
                width: 100%; /* Take full width */
            }
        }

        @media (max-width: 768px) {
            .sidebar {
                width: 250px; /* Retain original mobile sidebar width */
                position: fixed; /* Make sidebar fixed on smaller screens */
                height: 100%;
                top: 0;
                left: 0;
                z-index: 999;
                padding-top: 0; /* Removed this, sidebar-header handles it */
                transform: translateX(0); /* Default position for fixed sidebar */
            }
            .sidebar.hidden {
                left: -250px; /* Hide completely off-screen */
                width: 0;
                transform: translateX(0); /* Fixed sidebars often use left/right for hiding */
            }
            #showSidebarIconContainer {
                position: fixed; /* Keep fixed for mobile */
                left: 10px; /* Adjust button position */
                top: 10px;
                padding: 10px 15px; /* Larger padding for mobile touch targets */
                font-size: 16px;
            }
            .main-content {
                margin-left: 0; /* No margin on smaller screens */
                padding: 15px; /* Adjust padding for smaller screens */
            }
            body.sidebar-hidden .main-content {
                margin-left: 0; /* When sidebar is hidden, main content still uses full width */
            }
            /* Adjust main content left margin when sidebar is NOT hidden on mobile */
            body:not(.sidebar-hidden) .main-content {
                margin-left: 250px; /* Consistent with mobile sidebar width */
            }
            .quiz-content-panel,
            .quiz-interaction-panel {
                padding: 20px; /* Reduce panel padding */
            }
        }

        @media (max-width: 480px) {
            /* Further adjustments for very small screens */
            .sidebar {
                width: 100%;
                left: 0;
            }
            .sidebar.hidden {
                left: -100%;
            }
            .controls {
                flex-direction: column;
                align-items: stretch;
            }
            .control-button, .timer-display, .score-display {
                width: 100%;
                text-align: center;
            }
            .quiz-content-panel,
            .quiz-interaction-panel {
                padding: 15px; /* Further reduce panel padding */
            }
            .options-container {
                max-height: 300px; /* Further reduce max-height on tiny screens */
            }
        }
    </style>
</head>
<body>
    <!-- 侧边栏隐藏时显示的图标容器，初始隐藏 -->
    <button id="showSidebarIconContainer">
        <i class="fas fa-chevron-circle-right"></i> <!-- 菜单图标 -->
    </button>

    <div class="quiz-container">
        <!-- Sidebar Navigation -->
        <div id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h2>测验导航 <i id="hideSidebarIcon" class="fas fa-chevron-circle-left"></i></h2>
                <!-- Custom Type Filter Dropdown -->
                <div class="custom-dropdown" id="custom-quiz-type-filter">
                    <div class="dropdown-toggle" id="quiz-type-toggle">
                        <span id="selected-quiz-type">全部题型</span>
                        <i class="fas fa-chevron-down dropdown-arrow"></i>
                    </div>
                    <ul class="dropdown-menu" id="quiz-type-menu">
                        <!-- Options will be populated by JavaScript -->
                    </ul>
                </div>
            </div>
            <div class="sidebar-content">
                <ul id="quiz-nav" class="quiz-nav">
                    <!-- Quiz titles will be inserted here by JavaScript -->
                </ul>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="main-content">
            <div class="main-content-inner-wrapper"> <!-- NEW INNER WRAPPER for horizontal layout -->
                <!-- Left Panel: Question Text -->
                <div class="quiz-content-panel">
                    <h2 id="quiz-title"></h2>
                    <div id="quiz-type"></div>
                    <!-- New wrapper for just the scrollable content -->
                    <div id="question-text-scroll-wrapper">
                        <!-- Media container will be inserted here if available -->
                        <div id="question-media-container"></div> 
                        <p id="quiz-content" class="question-content"></p>
                    </div>
                </div>

                <!-- Right Panel: Controls and Options -->
                <div class="quiz-interaction-panel">
                    <div class="controls">
                        <button id="start-quiz-btn" class="control-button">开始作答</button>
                        <div id="timer" class="timer-display">时间: 00:00</div>
                        <div id="score-display" class="score-display">正确率: 0/0 (0%)</div>
                        <button id="submit-quiz-btn" class="control-button">交卷</button>
                    </div>

                    <div id="options-container" class="options-container">
                        <!-- Question blocks and choices will be inserted here by JavaScript -->
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // QuizApp Class to encapsulate all quiz logic and state
        class QuizApp {
            constructor() {
                // DOM Elements
                this.body = document.body;
                this.sidebar = document.getElementById('sidebar');
                this.showSidebarIconContainer = document.getElementById('showSidebarIconContainer');
                this.hideSidebarIcon = document.getElementById('hideSidebarIcon');
                this.quizNav = document.getElementById('quiz-nav');
                
                // Custom Dropdown Elements
                this.customQuizTypeFilter = document.getElementById('custom-quiz-type-filter');
                this.quizTypeToggle = document.getElementById('quiz-type-toggle');
                this.selectedQuizTypeSpan = document.getElementById('selected-quiz-type');
                this.quizTypeMenu = document.getElementById('quiz-type-menu');
                this.dropdownArrow = this.quizTypeToggle.querySelector('.dropdown-arrow');


                this.quizTitleElement = document.getElementById('quiz-title');
                this.quizTypeElement = document.getElementById('quiz-type');
                this.questionMediaContainer = document.getElementById('question-media-container'); // New media container
                this.quizContentElement = document.getElementById('quiz-content');
                this.optionsContainer = document.getElementById('options-container');
                this.startQuizBtn = document.getElementById('start-quiz-btn');
                this.submitQuizBtn = document.getElementById('submit-quiz-btn');
                this.timerDisplay = document.getElementById('timer');
                this.scoreDisplay = document.getElementById('score-display');

                // State Variables
                this.currentQuizIndex = 0;
                this.userAnswers = {}; // Stores user answers for the current quiz
                this.timerInterval = null;
                this.startTime = null;
                this.quizStarted = false;
                this.quizSubmitted = false;
                this.quizScores = {}; // Stores scores for completed quizzes { quizId: { correct, total, percentage, time, userAnswers } }
                this.selectedQuizType = 'all'; // Keep track of the selected filter type

                // Matching specific state for drag-and-drop
                this.draggedLeftItemValue = null; // Value of the item currently being dragged from the left column
            }

            /**
             * Initializes the Quiz Application.
             * Sets up event listeners and loads the initial quiz.
             */
            init() {
                // Check if quizData is loaded
                if (typeof quizData === 'undefined') {
                    console.error("Error: quiz_data.js not loaded. Please ensure the file is in the same directory and loaded correctly.");
                    return;
                }

                this.addEventListeners();
                this.populateTypeFilter();
                this.loadQuizNavigation();

                // Set initial sidebar state (assuming open by default)
                this.body.classList.remove('sidebar-hidden');
                this.sidebar.classList.remove('hidden');
                this.showSidebarIconContainer.style.display = 'none';
            }

            /**
             * Adds all necessary event listeners to DOM elements.
             */
            addEventListeners() {
                this.showSidebarIconContainer.addEventListener('click', this.toggleSidebar.bind(this));
                this.hideSidebarIcon.addEventListener('click', this.toggleSidebar.bind(this));

                this.startQuizBtn.addEventListener('click', this.startQuiz.bind(this));
                this.submitQuizBtn.addEventListener('click', this.handleSubmitReattempt.bind(this));
                
                // Event listeners for custom dropdown
                this.quizTypeToggle.addEventListener('click', this.toggleDropdown.bind(this));
                // Close dropdown if clicked outside
                document.addEventListener('click', (event) => {
                    if (!this.customQuizTypeFilter.contains(event.target)) {
                        this.hideDropdown();
                    }
                });
            }

            /**
             * Toggles the visibility of the sidebar.
             */
            toggleSidebar() {
                this.sidebar.classList.toggle('hidden');
                this.body.classList.toggle('sidebar-hidden');
                
                if (this.sidebar.classList.contains('hidden')) {
                    this.showSidebarIconContainer.style.display = 'flex';
                } else {
                    this.showSidebarIconContainer.style.display = 'none';
                }
            }

            /**
             * Toggles the visibility of the custom dropdown menu.
             */
            toggleDropdown() {
                this.quizTypeMenu.classList.toggle('show');
                this.quizTypeToggle.classList.toggle('active');
            }

            /**
             * Hides the custom dropdown menu.
             */
            hideDropdown() {
                this.quizTypeMenu.classList.remove('show');
                this.quizTypeToggle.classList.remove('active');
            }

            /**
             * Populates the custom dropdown menu with unique quiz types.
             */
            populateTypeFilter() {
                const types = new Set();
                quizData.questions.forEach(quiz => {
                    // Use the 'type' field for the high-level filter dropdown
                    if (quiz.type) {
                        types.add(quiz.type);
                    }
                });

                this.quizTypeMenu.innerHTML = ''; // Clear existing menu items

                // Add "All Types" option
                const allOption = document.createElement('li');
                allOption.textContent = '全部题型';
                allOption.dataset.value = 'all';
                allOption.addEventListener('click', () => this.selectDropdownOption('all', '全部题型'));
                this.quizTypeMenu.appendChild(allOption);

                // Add unique types
                types.forEach(type => {
                    const option = document.createElement('li');
                    option.textContent = type;
                    option.dataset.value = type;
                    option.addEventListener('click', () => this.selectDropdownOption(type, type));
                    this.quizTypeMenu.appendChild(option);
                });
            }

            /**
             * Handles the selection of a custom dropdown option.
             * @param {string} value - The data value of the selected option.
             * @param {string} text - The display text of the selected option.
             */
            selectDropdownOption(value, text) {
                this.selectedQuizTypeSpan.textContent = text;
                this.selectedQuizType = value; // Update the state variable
                this.hideDropdown();
                this.filterQuizNavigation(); // Apply the filter
            }

            /**
             * Filters the quiz navigation list based on the selected type from the custom dropdown.
             */
            filterQuizNavigation() {
                this.loadQuizNavigation(this.selectedQuizType); // Use the stored selected type
            }

            /**
             * Loads and displays the quiz navigation list, optionally filtered by type.
             * @param {string} filterType - The type to filter by, or 'all' for no filter.
             */
            loadQuizNavigation(filterType = 'all') {
                this.quizNav.innerHTML = '';
                const filteredQuizzes = quizData.questions.filter(quiz => {
                    return filterType === 'all' || quiz.type === filterType;
                });

                if (filteredQuizzes.length === 0 && quizData.questions.length > 0) {
                    // If current filter yields no results, reset to 'all' and reload
                    this.selectedQuizType = 'all'; 
                    this.selectedQuizTypeSpan.textContent = '全部题型';
                    this.loadQuizNavigation('all');
                    return;
                }
                if (filteredQuizzes.length === 0) {
                    // No quizzes at all or no quizzes after resetting filter
                    const noQuizzesItem = document.createElement('li');
                    noQuizzesItem.textContent = '没有可用的测验';
                    noQuizzesItem.style.cursor = 'default';
                    noQuizzesItem.style.opacity = '0.7';
                    this.quizNav.appendChild(noQuizzesItem);
                    this.resetQuizDisplay(); // Clear main content
                    return;
                }

                filteredQuizzes.forEach((quiz, index) => {
                    const listItem = document.createElement('li');
                    listItem.textContent = `${index + 1}. ${quiz.title}`;
                    listItem.dataset.originalIndex = quizData.questions.indexOf(quiz); // Store original index
                    listItem.title = quiz.title;
                    listItem.addEventListener('click', () => {
                        this.loadQuiz(parseInt(listItem.dataset.originalIndex));
                    });
                    this.quizNav.appendChild(listItem);
                });

                // Determine which quiz to load after filtering
                let targetQuizIndex = this.currentQuizIndex;
                const currentQuizExistsInFiltered = filteredQuizzes.some(q => quizData.questions.indexOf(q) === targetQuizIndex);

                // If the current quiz is no longer in the filtered list, load the first one
                if (!currentQuizExistsInFiltered && filteredQuizzes.length > 0) {
                    targetQuizIndex = quizData.questions.indexOf(filteredQuizzes[0]); // Load the first quiz in the filtered list
                } else if (filteredQuizzes.length === 0) {
                     targetQuizIndex = -1; // No quizzes to load
                }

                // If after filtering, the currentQuizIndex is out of bounds or no quizzes,
                // try to set it to 0 if there are any quizzes.
                // This specifically handles the "last item not showing" if the user was on it
                // and then filtered, or if the initial load was on an out-of-bounds index.
                if (quizData.questions.length > 0 && (targetQuizIndex === -1 || targetQuizIndex >= quizData.questions.length)) {
                    targetQuizIndex = 0; // Default to first quiz if current is invalid
                }


                if (targetQuizIndex !== -1) {
                    this.loadQuiz(targetQuizIndex);
                } else {
                    this.resetQuizDisplay(); // Clear main content if no quiz can be loaded
                }
            }

            /**
             * Resets the main quiz display area to a blank state.
             */
            resetQuizDisplay() {
                this.quizTitleElement.textContent = '';
                this.quizTypeElement.textContent = '';
                this.questionMediaContainer.innerHTML = ''; // Clear media
                this.quizContentElement.innerHTML = '';
                this.optionsContainer.innerHTML = '';
                this.startQuizBtn.disabled = true;
                this.submitQuizBtn.disabled = true;
                this.scoreDisplay.textContent = '正确率: 0/0 (0%)';
                this.timerDisplay.textContent = '时间: 00:00';
            }


            /**
             * Resets the quiz to its initial unstarted state.
             * This includes timer, score, user answers, and button states.
             */
            resetQuizState() {
                clearInterval(this.timerInterval);
                this.timerInterval = null;
                this.startTime = null;
                this.quizStarted = false;
                this.quizSubmitted = false;
                this.userAnswers = {}; // Clear user answers for the new attempt
                this.draggedLeftItemValue = null; // Reset dragged item for matching

                // Reset button states and displays
                this.disableOptions(); // This also clears existing answer highlights/explanations
                this.startQuizBtn.disabled = false;
                this.submitQuizBtn.disabled = true;
                this.submitQuizBtn.textContent = '交卷';
                this.scoreDisplay.textContent = '正确率: 0/0 (0%)';
                this.timerDisplay.textContent = '时间: 00:00';

                // Clear question media and content
                this.questionMediaContainer.innerHTML = '';
                this.quizContentElement.innerHTML = '';
                this.optionsContainer.innerHTML = '';

                // Remove highlight from question numbers in content
                this.quizContentElement.querySelectorAll('.question-num-in-text').forEach(span => {
                    span.classList.remove('highlighted-question-num');
                });
            }


            /**
             * Loads and displays a specific quiz based on its original index in quizData.questions.
             * @param {number} originalIndex - The original index of the quiz in quizData.questions.
             */
            loadQuiz(originalIndex) {
                this.resetQuizState(); // Reset state before loading new quiz content

                this.currentQuizIndex = originalIndex;
                const currentQuiz = quizData.questions[this.currentQuizIndex];

                // Update active state in sidebar navigation
                Array.from(this.quizNav.children).forEach(li => {
                    li.classList.remove('active');
                    if (parseInt(li.dataset.originalIndex) === this.currentQuizIndex) {
                        li.classList.add('active');
                    }
                });

                this.quizTitleElement.textContent = currentQuiz.title;
                this.quizTypeElement.textContent = `类型: ${currentQuiz.type} (${this.mapQuestionTypeToChinese(currentQuiz.questionType)})`;
                
                // Render media if available
                this.questionMediaContainer.innerHTML = ''; // Clear previous media
                if (currentQuiz.mediaUrl && currentQuiz.mediaType) {
                    if (currentQuiz.mediaType === 'video') {
                        const videoElement = document.createElement('video');
                        videoElement.controls = true;
                        videoElement.classList.add('question-media-video');
                        videoElement.src = currentQuiz.mediaUrl;
                        videoElement.innerHTML = '您的浏览器不支持视频播放。';
                        videoElement.autoplay = false; // Ensure it doesn't autoplay before `startQuiz`
                        this.questionMediaContainer.appendChild(videoElement);
                    }
                    // Add more media types (image, audio) here if needed in the future
                }

                // Format quiz content for question number highlighting (primarily for single-choice/cloze)
                let formattedContent = currentQuiz.content || ''; // Ensure content exists
                if (currentQuiz.questionType === 'single-choice' || currentQuiz.questionType === 'fill-in-blank') { 
                    const optionsToHighlight = currentQuiz.questionType === 'single-choice' ? 
                        currentQuiz.options : currentQuiz.options[0].blanks; // Use blanks for fill-in-blank

                    optionsToHighlight.forEach((item, itemIndex) => {
                        const questionNumText = item.label || item.question; // Use label for blanks, question for single-choice
                        const questionNumMatch = questionNumText.match(/\d+/);
                        if (questionNumMatch) {
                            const questionNum = questionNumMatch[0];
                            // More robust regex for question numbers like "1．", "(7)", "96.", "(1)"
                            const fullQuestionMatch = new RegExp(`(?<!<span[^>]*?>)(${this.escapeRegExp(questionNumText)})(?!<\\/span>)`, 'g');

                            if (formattedContent.match(fullQuestionMatch)) {
                                formattedContent = formattedContent.replace(fullQuestionMatch, `<span class="question-num-in-text" data-qindex="${itemIndex}">$&</span>`);
                            } else {
                                // Fallback for cases where full question doesn't match directly, try just the number
                                const simpleNumRegex = new RegExp(`(?<!<span[^>]*?>)(\\b${questionNum}\\b[\\.\\uff0e)]?|\\(${questionNum}\\))(?!<\\/span>)`, 'g');
                                formattedContent = formattedContent.replace(simpleNumRegex, `<span class="question-num-in-text" data-qindex="${itemIndex}">$&</span>`);
                            }
                        }
                    });
                }
                this.quizContentElement.innerHTML = formattedContent;


                // Render options based on question type
                switch (currentQuiz.questionType) {
                    case 'single-choice':
                    case 'multi-choice':
                    case 'true-false':
                        this.renderChoiceBasedQuestions(currentQuiz);
                        break;
                    case 'fill-in-blank':
                        this.renderFillInBlankQuestion(currentQuiz);
                        break;
                    case 'matching':
                        this.renderMatchingQuestion(currentQuiz);
                        break;
                    default:
                        this.optionsContainer.innerHTML = '<p>不支持的题型。</p>';
                        this.startQuizBtn.disabled = true;
                        this.submitQuizBtn.disabled = true;
                        break;
                }

                // Attach click listeners to question number spans if present
                this.quizContentElement.querySelectorAll('.question-num-in-text').forEach(span => {
                    span.addEventListener('click', (event) => {
                        const qIndex = parseInt(event.target.dataset.qindex);
                        const targetBlock = this.optionsContainer.querySelector(`.fill-in-blank-input[data-blank-index="${qIndex}"]`) || 
                                            this.optionsContainer.querySelector(`.question-block[data-question-index="${qIndex}"]`); // Fallback for general question blocks
                        if (targetBlock) {
                            targetBlock.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                            // Optional: temporarily highlight the block
                            targetBlock.style.border = '2px solid #87CEEB';
                            setTimeout(() => {
                                targetBlock.style.border = '1px solid transparent';
                            }, 1000);
                        }
                    });
                });

                // If quiz was previously submitted, apply its state
                if (this.quizScores[currentQuiz.id]) {
                    this.applySubmittedState();
                }
            }

            /**
             * Renders single-choice, multi-choice, and true-false questions.
             * @param {object} quizData - The current quiz object.
             */
            renderChoiceBasedQuestions(quizData) {
                quizData.options.forEach((option, optionIndex) => {
                    const questionBlockDiv = document.createElement('div');
                    questionBlockDiv.classList.add('question-block');
                    questionBlockDiv.dataset.questionIndex = optionIndex;
                    // Store the correct answer directly for simpler access during submission
                    questionBlockDiv.dataset.correctAnswer = JSON.stringify(option.answer); 

                    const questionSubTitle = document.createElement('div');
                    questionSubTitle.classList.add('question-sub-title');
                    questionSubTitle.textContent = option.question;

                    const choicesWrapper = document.createElement('div');
                    choicesWrapper.classList.add('choices-wrapper');

                    Object.keys(option.choices).forEach(choiceKey => {
                        const choiceItemDiv = document.createElement('div');
                        choiceItemDiv.classList.add('choice-item');
                        choiceItemDiv.dataset.choice = choiceKey;
                        choiceItemDiv.textContent = `${choiceKey}. ${option.choices[choiceKey]}`;
                        choicesWrapper.appendChild(choiceItemDiv);

                        choiceItemDiv.addEventListener('click', () => {
                            if (!this.quizStarted || this.quizSubmitted) return;
                            this.handleChoiceAnswer(quizData.questionType, optionIndex, choiceKey, questionBlockDiv);
                        });
                    });

                    const questionExplanationDiv = document.createElement('div');
                    questionExplanationDiv.classList.add('question-explanation');
                    questionExplanationDiv.style.display = 'none';

                    questionBlockDiv.appendChild(questionSubTitle);
                    questionBlockDiv.appendChild(choicesWrapper);
                    questionBlockDiv.appendChild(questionExplanationDiv);
                    this.optionsContainer.appendChild(questionBlockDiv);
                });
            }

            /**
             * Handles user selection for choice-based questions (single, multi, true-false).
             * @param {string} type - The question type ("single-choice", "multi-choice", "true-false").
             * @param {number} questionIndex - The index of the sub-question.
             * @param {string} selectedChoice - The choice key (e.g., 'A', 'B').
             * @param {HTMLElement} questionBlockDiv - The DOM element for the current question block.
             */
            handleChoiceAnswer(type, questionIndex, selectedChoice, questionBlockDiv) {
                if (type === 'single-choice' || type === 'true-false') {
                    // For single-choice/true-false, only one option can be selected
                    questionBlockDiv.querySelectorAll('.choice-item').forEach(choiceElement => {
                        choiceElement.classList.remove('selected-choice');
                    });
                    questionBlockDiv.querySelector(`.choice-item[data-choice="${selectedChoice}"]`).classList.add('selected-choice');
                    this.userAnswers[questionIndex] = selectedChoice; // Store single string
                } else if (type === 'multi-choice') {
                    // For multi-choice, toggle selection
                    const currentSelectionElement = questionBlockDiv.querySelector(`.choice-item[data-choice="${selectedChoice}"]`);
                    currentSelectionElement.classList.toggle('selected-choice');

                    let currentAnswers = this.userAnswers[questionIndex] || [];
                    if (currentSelectionElement.classList.contains('selected-choice')) {
                        if (!currentAnswers.includes(selectedChoice)) {
                            currentAnswers.push(selectedChoice);
                        }
                    } else {
                        currentAnswers = currentAnswers.filter(ans => ans !== selectedChoice);
                    }
                    this.userAnswers[questionIndex] = currentAnswers; // Store array of choices
                }

                // Update highlighted question number in content
                this.quizContentElement.querySelectorAll('.question-num-in-text').forEach(span => {
                    if (parseInt(span.dataset.qindex) === questionIndex) {
                        span.classList.add('highlighted-question-num');
                    } else {
                        span.classList.remove('highlighted-question-num');
                    }
                });
                questionBlockDiv.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
            }

            /**
             * Renders a fill-in-blank question, supporting multiple blanks.
             * @param {object} quizData - The current quiz object.
             */
            renderFillInBlankQuestion(quizData) {
                // Fill-in-blank usually has only one "option" object for the entire blank sentence
                const option = quizData.options[0]; 
                const optionIndex = 0; // Always 0 for fill-in-blank as it's a single question type for submission

                const questionBlockDiv = document.createElement('div');
                questionBlockDiv.classList.add('question-block');
                questionBlockDiv.dataset.questionIndex = optionIndex;
                questionBlockDiv.dataset.correctAnswer = JSON.stringify(option.answer); // Store answer array as string

                const questionSubTitle = document.createElement('div');
                questionSubTitle.classList.add('question-sub-title');
                // Use the question text from options, not the main content which might be the full text
                questionSubTitle.textContent = option.question; 

                const fillInBlankContentWrapper = document.createElement('div');
                fillInBlankContentWrapper.classList.add('fill-in-blank-container');

                this.userAnswers[optionIndex] = this.userAnswers[optionIndex] || new Array(option.blankCount).fill(''); // Initialize user answers array for blanks

                // Iterate through the 'blanks' array in the option data to create specific inputs
                option.blanks.forEach((blankData, i) => {
                    const blankLabel = document.createElement('span');
                    blankLabel.classList.add('fill-in-blank-text-part');
                    blankLabel.textContent = `${blankData.label} `; // Display label from data (e.g., "(1)")
                    fillInBlankContentWrapper.appendChild(blankLabel);

                    const inputElement = document.createElement('input');
                    inputElement.type = 'text';
                    inputElement.classList.add('fill-in-blank-input');
                    inputElement.placeholder = blankData.placeholder; // Use placeholder from data
                    inputElement.dataset.blankIndex = i; // Store which blank this input corresponds to
                    inputElement.disabled = true; // Initially disabled

                    // Restore user's previous answer if available
                    if (this.userAnswers[optionIndex][i]) {
                        inputElement.value = this.userAnswers[optionIndex][i];
                    }

                    inputElement.addEventListener('input', (event) => {
                        if (!this.quizStarted || this.quizSubmitted) return;
                        const blankIdx = parseInt(event.target.dataset.blankIndex);
                        this.userAnswers[optionIndex][blankIdx] = event.target.value.trim();
                    });
                    fillInBlankContentWrapper.appendChild(inputElement);
                });

                const questionExplanationDiv = document.createElement('div');
                questionExplanationDiv.classList.add('question-explanation');
                questionExplanationDiv.style.display = 'none';

                questionBlockDiv.appendChild(questionSubTitle);
                questionBlockDiv.appendChild(fillInBlankContentWrapper);
                questionBlockDiv.appendChild(questionExplanationDiv);
                this.optionsContainer.appendChild(questionBlockDiv);
            }

            /**
             * Renders a matching question.
             * @param {object} quizData - The current quiz object.
             */
            renderMatchingQuestion(quizData) {
                // Matching question typically has only one "option" object for all pairs
                const option = quizData.options[0];
                const optionIndex = 0; // Always 0 for matching

                const questionBlockDiv = document.createElement('div');
                questionBlockDiv.classList.add('question-block');
                questionBlockDiv.dataset.questionIndex = optionIndex;
                // Store the full answer object for this question
                questionBlockDiv.dataset.correctAnswer = JSON.stringify(option.answer);

                const questionSubTitle = document.createElement('div');
                questionSubTitle.classList.add('question-sub-title');
                questionSubTitle.textContent = option.question;

                const matchingContainer = document.createElement('div');
                matchingContainer.classList.add('matching-container');

                const leftColumn = document.createElement('div');
                leftColumn.classList.add('matching-column', 'left-column');
                const rightColumn = document.createElement('div');
                rightColumn.classList.add('matching-column', 'right-column');

                // Shuffle pairs for display to ensure randomness (optional, but good practice)
                const shuffledPairs = [...option.pairs];
                // Separate left and right items, shuffle them individually
                const leftItems = shuffledPairs.map(p => p.left).sort(() => Math.random() - 0.5);
                const rightItems = shuffledPairs.map(p => p.right).sort(() => Math.random() - 0.5);

                leftItems.forEach(leftValue => {
                    const leftItem = document.createElement('div');
                    leftItem.classList.add('matching-item', 'left-item');
                    leftItem.dataset.value = leftValue;
                    leftItem.textContent = leftValue;
                    leftItem.draggable = true; // Make left items draggable

                    // Drag event listeners for the left item
                    leftItem.addEventListener('dragstart', (event) => this.handleDragStart(event, leftValue));
                    leftItem.addEventListener('dragend', (event) => {
                        event.target.classList.remove('dragging'); // Remove dragging class
                    });

                    leftColumn.appendChild(leftItem);
                });

                rightItems.forEach(rightValue => {
                    const rightItem = document.createElement('div');
                    rightItem.classList.add('matching-item', 'right-item');
                    rightItem.dataset.value = rightValue;
                    rightItem.textContent = rightValue;
                    
                    // Drop event listeners for the right item
                    rightItem.addEventListener('dragover', (event) => this.handleDragOver(event));
                    rightItem.addEventListener('dragleave', (event) => this.handleDragLeave(event));
                    rightItem.addEventListener('drop', (event) => this.handleDrop(event, optionIndex, rightItem));

                    rightColumn.appendChild(rightItem);
                });

                matchingContainer.appendChild(leftColumn);
                matchingContainer.appendChild(rightColumn);

                // Add the display area for user's matched pairs
                const userPairsDisplayDiv = document.createElement('div');
                userPairsDisplayDiv.classList.add('matching-user-pairs-display');
                userPairsDisplayDiv.innerHTML = '<h4>已作答匹配：</h4><div id="matched-pairs-list"></div>'; // Sub-container for list
                
                const questionExplanationDiv = document.createElement('div');
                questionExplanationDiv.classList.add('question-explanation');
                questionExplanationDiv.style.display = 'none';

                questionBlockDiv.appendChild(questionSubTitle);
                questionBlockDiv.appendChild(matchingContainer);
                questionBlockDiv.appendChild(userPairsDisplayDiv); // Append the new display area
                questionBlockDiv.appendChild(questionExplanationDiv);
                this.optionsContainer.appendChild(questionBlockDiv);

                // Initialize user answers for matching as an object to store pairs
                this.userAnswers[optionIndex] = this.userAnswers[optionIndex] || {};

                // Initially render the user pairs display based on existing answers (if any)
                this.updateMatchingUserPairsDisplay(optionIndex);

                 // If previously submitted, apply the saved state
                if (this.quizScores[quizData.id] && this.quizScores[quizData.id].userAnswers && this.quizScores[quizData.id].userAnswers[optionIndex]) {
                    const savedUserPairs = this.quizScores[quizData.id].userAnswers[optionIndex];
                    for (const leftVal in savedUserPairs) {
                        const rightVal = savedUserPairs[leftVal];
                        const leftElem = questionBlockDiv.querySelector(`.left-item[data-value="${leftVal}"]`);
                        const rightElem = questionBlockDiv.querySelector(`.right-item[data-value="${rightVal}"]`);
                        if (leftElem && rightElem) {
                            // Apply 'connected' state for correct pairs, or 'incorrect' for wrong ones
                            const correctMappings = JSON.parse(questionBlockDiv.dataset.correctAnswer);
                            if (correctMappings[leftVal] === rightVal) {
                                leftElem.classList.add('matching-connected');
                                rightElem.classList.add('matching-connected');
                            } else {
                                leftElem.classList.add('matching-incorrect');
                                rightElem.classList.add('matching-incorrect');
                                // Highlight the correct right answer if user's was wrong
                                const actualCorrectRightElem = questionBlockDiv.querySelector(`.right-item[data-value="${correctMappings[leftVal]}"]`);
                                if (actualCorrectRightElem) {
                                    actualCorrectRightElem.classList.add('correct-choice'); // Using existing class for highlighting
                                }
                            }
                            leftElem.classList.add('disabled');
                            rightElem.classList.add('disabled');
                        }
                    }
                }
            }

            /**
             * Handles the dragstart event for left matching items.
             * @param {DragEvent} event - The drag event.
             * @param {string} value - The value of the dragged item.
             */
            handleDragStart(event, value) {
                if (!this.quizStarted || this.quizSubmitted) {
                    event.preventDefault(); // Prevent dragging if quiz not started or submitted
                    return;
                }
                this.draggedLeftItemValue = value;
                event.dataTransfer.setData('text/plain', value); // Set data for drag operation
                event.target.classList.add('dragging'); // Add visual feedback for dragging

                // If this left item was already paired, remove the old pairing from userAnswers
                // This allows re-pairing and dynamic updates.
                const currentQuiz = quizData.questions[this.currentQuizIndex];
                const optionIndex = 0; // Matching is always optionIndex 0
                if (this.userAnswers[optionIndex] && this.userAnswers[optionIndex][value]) {
                    const oldRightValue = this.userAnswers[optionIndex][value];
                    delete this.userAnswers[optionIndex][value]; // Remove the old pair

                    // Remove connected/disabled classes from the previously matched right item
                    const questionBlockDiv = event.target.closest('.question-block');
                    if (questionBlockDiv) {
                        const oldRightElem = questionBlockDiv.querySelector(`.right-item[data-value="${oldRightValue}"]`);
                        if (oldRightElem) {
                            oldRightElem.classList.remove('matching-connected', 'disabled');
                            oldRightElem.style.pointerEvents = 'auto'; // Re-enable pointer events
                        }
                    }
                    this.updateMatchingUserPairsDisplay(optionIndex); // Update display
                }
            }

            /**
             * Handles the dragover event for right matching items (drop targets).
             * @param {DragEvent} event - The drag event.
             */
            handleDragOver(event) {
                if (!this.quizStarted || this.quizSubmitted) {
                    event.preventDefault();
                    return;
                }
                event.preventDefault(); // Necessary to allow dropping
                event.dataTransfer.dropEffect = 'move'; // Visual feedback for allowed drop
                event.target.classList.add('drag-over'); // Highlight drop target
            }

            /**
             * Handles the dragleave event for right matching items.
             * @param {DragEvent} event - The drag event.
             */
            handleDragLeave(event) {
                event.target.classList.remove('drag-over'); // Remove highlight
            }

            /**
             * Handles the drop event for right matching items.
             * @param {DragEvent} event - The drag event.
             * @param {number} questionIndex - The index of the matching question.
             * @param {HTMLElement} dropTargetItem - The right item element that was dropped on.
             */
            handleDrop(event, questionIndex, dropTargetItem) {
                if (!this.quizStarted || this.quizSubmitted) return;

                event.preventDefault();
                event.target.classList.remove('drag-over'); // Remove highlight

                const draggedValue = event.dataTransfer.getData('text/plain'); // Get value of the dragged left item
                const droppedOnValue = dropTargetItem.dataset.value; // Get value of the right item

                // Check if the dragged item is actually a left item and is from the current quiz
                if (draggedValue && this.draggedLeftItemValue === draggedValue) {
                    // Update userAnswers for the matching question (index 0)
                    this.userAnswers[questionIndex] = this.userAnswers[questionIndex] || {};
                    this.userAnswers[questionIndex][draggedValue] = droppedOnValue;

                    // Visually mark the dropped left item as connected/disabled
                    const questionBlockDiv = dropTargetItem.closest('.question-block');
                    if (questionBlockDiv) {
                        const draggedLeftElem = questionBlockDiv.querySelector(`.left-item[data-value="${draggedValue}"]`);
                        if (draggedLeftElem) {
                            draggedLeftElem.classList.add('matching-connected');
                            draggedLeftElem.classList.add('disabled');
                        }
                    }
                    dropTargetItem.classList.add('matching-connected'); // Mark right item as connected
                    dropTargetItem.classList.add('disabled'); // Disable the target right item

                    this.updateMatchingUserPairsDisplay(questionIndex); // Update the user pairs display
                }
                this.draggedLeftItemValue = null; // Reset dragged item value
            }

            /**
             * Updates the display area showing the user's current matched pairs for a matching question.
             * @param {number} questionIndex - The index of the matching question.
             */
            updateMatchingUserPairsDisplay(questionIndex) {
                const questionBlockDiv = this.optionsContainer.querySelector(`.question-block[data-question-index="${questionIndex}"]`);
                if (!questionBlockDiv) return;

                const matchedPairsList = questionBlockDiv.querySelector('#matched-pairs-list');
                if (!matchedPairsList) return;

                matchedPairsList.innerHTML = ''; // Clear previous display

                const userMappings = this.userAnswers[questionIndex] || {};
                const currentQuiz = quizData.questions[this.currentQuizIndex];
                const correctMappings = currentQuiz.options[0].answer; // The object of correct pairs

                const allLeftItems = currentQuiz.options[0].pairs.map(p => p.left);

                allLeftItems.forEach(leftValue => {
                    const rightValue = userMappings[leftValue];
                    if (rightValue) { // Only display if a pair exists for this left item
                        const pairDisplay = document.createElement('div');
                        pairDisplay.classList.add('matched-pair-item-display');
                        pairDisplay.innerHTML = `<span class="left-display">${leftValue}</span> <i class="fas fa-arrow-right"></i> <span class="right-display">${rightValue}</span>`;
                        
                        // Add remove button
                        const removeBtn = document.createElement('button');
                        removeBtn.classList.add('matched-pair-remove-btn');
                        removeBtn.innerHTML = '<i class="fas fa-times"></i>'; // Font Awesome close icon
                        removeBtn.title = `移除 ${leftValue} - ${rightValue} 匹配`;
                        removeBtn.addEventListener('click', () => {
                            if (!this.quizStarted || this.quizSubmitted) return;

                            // Re-enable the left and right items
                            const leftElem = questionBlockDiv.querySelector(`.left-item[data-value="${leftValue}"]`);
                            const rightElem = questionBlockDiv.querySelector(`.right-item[data-value="${rightValue}"]`);
                            
                            if (leftElem) {
                                leftElem.classList.remove('matching-connected', 'disabled');
                                leftElem.style.pointerEvents = 'auto';
                            }
                            if (rightElem) {
                                rightElem.classList.remove('matching-connected', 'disabled');
                                rightElem.style.pointerEvents = 'auto';
                            }

                            // Remove from userAnswers
                            delete this.userAnswers[questionIndex][leftValue];
                            this.updateMatchingUserPairsDisplay(questionIndex); // Update the display
                        });
                        pairDisplay.appendChild(removeBtn);
                        matchedPairsList.appendChild(pairDisplay);
                    }
                });

                // If no pairs are matched, show a message
                if (Object.keys(userMappings).length === 0) {
                    matchedPairsList.innerHTML = '<p style="text-align: center; color: #aaa;">暂无匹配关系</p>';
                }
            }


            /**
             * Starts the quiz timer and enables options.
             */
            startQuiz() {
                if (this.quizStarted) return;
                this.quizStarted = true;
                this.startTime = Date.now();
                this.timerInterval = setInterval(this.updateTimer.bind(this), 1000);
                this.startQuizBtn.disabled = true;
                this.submitQuizBtn.disabled = false;
                this.submitQuizBtn.textContent = '交卷';
                this.enableOptions();
                this.scoreDisplay.textContent = '正确率: 未作答';

                // Play video if present
                const currentQuiz = quizData.questions[this.currentQuizIndex];
                if (currentQuiz.mediaType === 'video') {
                    const videoElement = this.questionMediaContainer.querySelector('video');
                    if (videoElement) {
                        videoElement.play().catch(e => console.error("Video autoplay prevented:", e));
                    }
                }

                // Hide sidebar automatically on quiz start
                if (!this.sidebar.classList.contains('hidden')) {
                    this.sidebar.classList.add('hidden');
                    this.body.classList.add('sidebar-hidden');
                    this.showSidebarIconContainer.style.display = 'flex';
                }
            }

            /**
             * Updates the timer display every second.
             */
            updateTimer() {
                const elapsedTime = Date.now() - this.startTime;
                const minutes = Math.floor(elapsedTime / 60000);
                const seconds = Math.floor((elapsedTime % 60000) / 1000);
                this.timerDisplay.textContent = `时间: ${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }

            /**
             * Enables all quiz options for user selection based on question type.
             */
            enableOptions() {
                const currentQuiz = quizData.questions[this.currentQuizIndex];
                if (!currentQuiz) return;

                if (currentQuiz.questionType === 'fill-in-blank') {
                    this.optionsContainer.querySelectorAll('.fill-in-blank-input').forEach(input => {
                        input.disabled = false;
                        input.classList.remove('disabled');
                    });
                } else if (currentQuiz.questionType === 'matching') {
                     this.optionsContainer.querySelectorAll('.matching-item').forEach(item => {
                        // Only enable if not already connected
                        if (!item.classList.contains('matching-connected')) {
                            item.classList.remove('disabled');
                            item.style.pointerEvents = 'auto';
                        }
                    });
                } else { // single-choice, multi-choice, true-false
                    this.optionsContainer.querySelectorAll('.choice-item').forEach(choiceItem => {
                        choiceItem.classList.remove('disabled');
                    });
                }
            }

            /**
             * Disables all quiz options and hides explanations.
             */
            disableOptions() {
                const currentQuiz = quizData.questions[this.currentQuizIndex];
                if (!currentQuiz) return;

                if (currentQuiz.questionType === 'fill-in-blank') {
                    this.optionsContainer.querySelectorAll('.fill-in-blank-input').forEach(input => {
                        input.disabled = true;
                        input.classList.add('disabled');
                        input.classList.remove('correct', 'incorrect'); // Remove previous result highlighting
                    });
                } else if (currentQuiz.questionType === 'matching') {
                     this.optionsContainer.querySelectorAll('.matching-item').forEach(item => {
                        item.classList.add('disabled');
                        item.style.pointerEvents = 'none'; // Absolutely prevent clicks
                        item.classList.remove('matching-selected-left', 'matching-selected-right', 'matching-connected', 'matching-incorrect', 'correct-choice'); // Clear matching specific states
                    });
                }
                else { // single-choice, multi-choice, true-false
                    this.optionsContainer.querySelectorAll('.choice-item').forEach(choiceItem => {
                        choiceItem.classList.add('disabled');
                        choiceItem.classList.remove('selected-choice', 'correct-choice', 'incorrect-choice');
                    });
                }
                this.optionsContainer.querySelectorAll('.question-explanation').forEach(explanationDiv => {
                    explanationDiv.style.display = 'none';
                });
                this.quizContentElement.querySelectorAll('.question-num-in-text').forEach(span => {
                    span.classList.remove('highlighted-question-num');
                });
            }

            /**
             * Handles quiz submission or re-attempt logic.
             */
            handleSubmitReattempt() {
                const currentQuiz = quizData.questions[this.currentQuizIndex];

                // Added a check to prevent submission if not started
                if (!this.quizStarted && !this.quizSubmitted) {
                    console.warn("Quiz not started yet. Please click '开始作答' first.");
                    return;
                }

                if (!this.quizSubmitted) {
                    // Logic for Initial Submission
                    clearInterval(this.timerInterval);
                    this.quizSubmitted = true;
                    this.startQuizBtn.disabled = true; // Disable Start button
                    this.submitQuizBtn.disabled = true; // Temporarily disable Submit button during processing
                    this.disableOptions(); // Disable all options after submission

                    let correctCount = 0;
                    let totalQuestions = 0;

                    this.quizContentElement.querySelectorAll('.question-num-in-text').forEach(span => {
                        span.classList.remove('highlighted-question-num');
                    });

                    // Evaluate answers based on question type
                    switch (currentQuiz.questionType) {
                        case 'single-choice':
                        case 'true-false':
                            totalQuestions = currentQuiz.options.length;
                            currentQuiz.options.forEach((optionData, optionIndex) => {
                                const questionBlockDiv = this.optionsContainer.querySelector(`.question-block[data-question-index="${optionIndex}"]`);
                                const correctAnswer = optionData.answer;
                                const userAnswer = this.userAnswers[optionIndex];
                                
                                let isCorrect = (userAnswer !== undefined && String(userAnswer) === String(correctAnswer));

                                questionBlockDiv.querySelectorAll('.choice-item').forEach(choiceElement => {
                                    const choiceKey = choiceElement.dataset.choice;
                                    choiceElement.classList.remove('selected-choice', 'correct-choice', 'incorrect-choice');
                                    
                                    if (String(choiceKey) === String(correctAnswer)) { // Highlight correct answer
                                        choiceElement.classList.add('correct-choice');
                                    }
                                    if (userAnswer !== undefined && String(userAnswer) === String(choiceKey) && !isCorrect) { // Highlight incorrect user answer
                                        choiceElement.classList.add('incorrect-choice');
                                    }
                                });

                                if (isCorrect) {
                                    correctCount++;
                                }
                                this.displayExplanation(questionBlockDiv, userAnswer, correctAnswer, optionData.explanation, optionData.choices, isCorrect, currentQuiz.questionType);
                            });
                            break;

                        case 'multi-choice':
                            totalQuestions = currentQuiz.options.length;
                            currentQuiz.options.forEach((optionData, optionIndex) => {
                                const questionBlockDiv = this.optionsContainer.querySelector(`.question-block[data-question-index="${optionIndex}"]`);
                                // Ensure correctAnswers is an array and sorted for consistent comparison
                                const correctAnswers = Array.isArray(optionData.answer) ? optionData.answer.sort() : [];
                                const userAnswers = (this.userAnswers[optionIndex] || []).sort();
                                
                                // Check if arrays are identical (same elements, same count)
                                let isCorrect = (correctAnswers.length === userAnswers.length &&
                                                 correctAnswers.every((val, idx) => val === userAnswers[idx]));

                                questionBlockDiv.querySelectorAll('.choice-item').forEach(choiceElement => {
                                    const choiceKey = choiceElement.dataset.choice;
                                    choiceElement.classList.remove('selected-choice', 'correct-choice', 'incorrect-choice'); // Clear selected first

                                    if (correctAnswers.includes(choiceKey)) { // Highlight all correct answers
                                        choiceElement.classList.add('correct-choice');
                                    }
                                    // Highlight user's incorrect selections (chosen but not correct, or not chosen but correct)
                                    if (userAnswers.includes(choiceKey) && !correctAnswers.includes(choiceKey)) {
                                        choiceElement.classList.add('incorrect-choice');
                                    }
                                    // Also consider correct answers not selected by the user as incorrect (visually)
                                    if (!userAnswers.includes(choiceKey) && correctAnswers.includes(choiceKey)) {
                                        // This case is already covered by correct-choice, but if the user missed it,
                                        // we want to ensure the correct answer is still highlighted correctly.
                                        // No additional class needed here, `correct-choice` is enough.
                                    }
                                });

                                if (isCorrect) {
                                    correctCount++;
                                }
                                this.displayExplanation(questionBlockDiv, userAnswers, correctAnswers, optionData.explanation, optionData.choices, isCorrect, currentQuiz.questionType);
                            });
                            break;

                        case 'fill-in-blank':
                            // For multi-blank fill-in, totalQuestions is blankCount
                            totalQuestions = currentQuiz.options[0].blankCount;
                            const fillInBlankOptionData = currentQuiz.options[0];
                            const fillInBlankQuestionBlockDiv = this.optionsContainer.querySelector(`.question-block[data-question-index="0"]`); // Only one option for fill-in-blank
                            const correctAnswersArray = fillInBlankOptionData.answer;
                            const userInputsArray = this.userAnswers[0] || new Array(totalQuestions).fill(''); // Ensure userInputsArray exists and is correct length

                            let fillInBlankExplanationContent = `<div class="explanation-item">`;
                            
                            for (let i = 0; i < totalQuestions; i++) {
                                const inputElement = fillInBlankQuestionBlockDiv.querySelector(`.fill-in-blank-input[data-blank-index="${i}"]`);
                                const correctAnswer = (correctAnswersArray[i] || '').toLowerCase().trim();
                                const userInput = (userInputsArray[i] || '').toLowerCase().trim();
                                
                                const isBlankCorrect = (userInput === correctAnswer);

                                inputElement.disabled = true; // Disable input field
                                inputElement.classList.add('disabled');

                                if (isBlankCorrect) {
                                    inputElement.classList.add('correct');
                                    correctCount++;
                                } else {
                                    inputElement.classList.add('incorrect');
                                }

                                fillInBlankExplanationContent += `<p>填空 ${i + 1}: `;
                                fillInBlankExplanationContent += `你的答案: <span class="your-answer">${userInputsArray[i] || '未作答'}</span> `;
                                fillInBlankExplanationContent += isBlankCorrect ? `<i class="fas fa-check-circle explanation-icon" style="color: #28a745;"></i> (正确)<br>` : `<i class="fas fa-times-circle explanation-icon" style="color: #dc3545;"></i> (错误)<br>`;
                                if (!isBlankCorrect) {
                                    fillInBlankExplanationContent += `正确答案: <span class="correct-answer">${correctAnswersArray[i]}</span><br>`;
                                }
                                fillInBlankExplanationContent += `</p>`;
                            }
                            fillInBlankExplanationContent += `<span class="explanation-text">解析: ${fillInBlankOptionData.explanation}</span></div>`;
                            fillInBlankQuestionBlockDiv.querySelector('.question-explanation').innerHTML = fillInBlankExplanationContent;
                            fillInBlankQuestionBlockDiv.querySelector('.question-explanation').style.display = 'block';
                            break;

                        case 'matching':
                            totalQuestions = currentQuiz.options[0].pairs.length; // Number of pairs is total questions
                            const correctMappings = currentQuiz.options[0].answer; // The object of correct pairs
                            const userMappings = this.userAnswers[0] || {}; // User's matched pairs for the single matching question

                            const matchingQuestionBlockDiv = this.optionsContainer.querySelector(`.question-block[data-question-index="0"]`);
                            
                            // Disable all matching items
                            matchingQuestionBlockDiv.querySelectorAll('.matching-item').forEach(item => {
                                item.classList.add('disabled');
                                item.style.pointerEvents = 'none';
                                item.classList.remove('matching-selected-left', 'matching-selected-right', 'dragging', 'drag-over'); // Clear any dragging/selection states
                            });
                            // Hide the user pairs display area during review
                            matchingQuestionBlockDiv.querySelector('.matching-user-pairs-display').style.display = 'none';


                            let matchingExplanationContent = `<div class="explanation-item"><h4>连线结果：</h4>`;
                            
                            // Iterate over the *correct* mappings to display all correct pairs and compare user answers
                            for (const leftKey in correctMappings) {
                                const expectedRight = correctMappings[leftKey];
                                const userRight = userMappings[leftKey]; // Get user's paired right for this left key
                                
                                const isPairCorrect = (userRight !== undefined && userRight === expectedRight);

                                const leftElem = matchingQuestionBlockDiv.querySelector(`.left-item[data-value="${leftKey}"]`);
                                const userRightElem = matchingQuestionBlockDiv.querySelector(`.right-item[data-value="${userRight}"]`); // User's chosen right
                                const correctRightElem = matchingQuestionBlockDiv.querySelector(`.right-item[data-value="${expectedRight}"]`); // Actual correct right

                                // Apply visual feedback to connected items
                                if (isPairCorrect) {
                                    correctCount++;
                                    if (leftElem) leftElem.classList.add('matching-connected');
                                    if (userRightElem) userRightElem.classList.add('matching-connected');
                                } else {
                                    if (leftElem) leftElem.classList.add('matching-incorrect');
                                    // If user made a choice, and it's incorrect, mark their choice as incorrect
                                    if (userRightElem && userRight) userRightElem.classList.add('matching-incorrect');
                                    // Always highlight the correct right answer
                                    if (correctRightElem) correctRightElem.classList.add('correct-choice'); // Using existing class for highlighting
                                }

                                // Add explanation for each pair
                                matchingExplanationContent += `<div class="matching-explanation-pair ${isPairCorrect ? 'correct' : 'incorrect'}">
                                    <span class="left-side">${leftKey}</span>
                                    <i class="fas ${isPairCorrect ? 'fa-check-circle' : 'fa-times-circle'}" style="color: ${isPairCorrect ? '#28a745' : '#dc3545'}; margin: 0 5px;"></i>
                                    <span class="right-side">${userRight || '未作答'} (正确: ${expectedRight})</span>
                                </div>`;
                            }
                            matchingExplanationContent += `<span class="explanation-text">解析: ${currentQuiz.options[0].explanation}</span></div>`;
                            matchingQuestionBlockDiv.querySelector('.question-explanation').innerHTML = matchingExplanationContent;
                            matchingQuestionBlockDiv.querySelector('.question-explanation').style.display = 'block';
                            break;
                    }


                    // Calculate and display overall score
                    const accuracyPercentage = totalQuestions === 0 ? 0 : ((correctCount / totalQuestions) * 100).toFixed(2);
                    this.scoreDisplay.textContent = `正确率: ${correctCount}/${totalQuestions} (${accuracyPercentage}%)`;

                    // Mark quiz as completed in navigation
                    const navItem = this.quizNav.querySelector(`li[data-original-index="${this.currentQuizIndex}"]`);
                    if (navItem) {
                        navItem.classList.add('completed');
                    }

                    // Store score and user answers for the main quiz ID
                    this.quizScores[currentQuiz.id] = {
                        correct: correctCount,
                        total: totalQuestions,
                        percentage: accuracyPercentage,
                        time: this.timerDisplay.textContent,
                        userAnswers: JSON.parse(JSON.stringify(this.userAnswers)) // Deep copy userAnswers
                    };

                    // After submission, enable submit button and change its text for re-attempt
                    this.submitQuizBtn.disabled = false;
                    this.submitQuizBtn.textContent = '重新作答';

                } else {
                    // Logic for Re-attempt after Submission
                    // Remove saved score and reset completed status in navigation
                    delete this.quizScores[currentQuiz.id];
                    const navItem = this.quizNav.querySelector(`li[data-original-index="${this.currentQuizIndex}"]`);
                    if (navItem) {
                        navItem.classList.remove('completed');
                    }
                    // Reload the current quiz to reset everything to a fresh, unstarted state
                    this.loadQuiz(this.currentQuizIndex);
                    // No need to set button states here, loadQuiz (via resetQuizState) handles it.
                }
            }

            /**
             * Displays the explanation for a given question block.
             * @param {HTMLElement} questionBlockDiv - The question block DOM element.
             * @param {*} userAnswer - The user's answer (string, array, or object).
             * @param {*} correctAnswer - The correct answer (string, array, or object).
             * @param {string} explanationText - The full explanation text.
             * @param {object} choices - The choices object (for choice-based questions).
             * @param {boolean} isCorrect - Whether the user's answer was correct.
             * @param {string} questionType - The type of question.
             */
            displayExplanation(questionBlockDiv, userAnswer, correctAnswer, explanationText, choices, isCorrect, questionType) {
                const questionExplanationDiv = questionBlockDiv.querySelector('.question-explanation');
                let explanationContent = `<div class="explanation-item">`;

                if (questionType === 'single-choice' || questionType === 'true-false') {
                    if (userAnswer !== undefined && choices && choices[userAnswer]) {
                        explanationContent += `你的答案: <span class="your-answer">${userAnswer}. ${choices[userAnswer]}</span> `;
                        explanationContent += isCorrect ? `<i class="fas fa-check-circle explanation-icon" style="color: #28a745;"></i> (正确)<br>` : `<i class="fas fa-times-circle explanation-icon" style="color: #dc3545;"></i> (错误)<br>`;
                        if (!isCorrect) {
                            explanationContent += `正确答案: <span class="correct-answer">${correctAnswer}. ${choices[correctAnswer]}</span><br>`;
                        }
                    } else {
                        explanationContent += `你的答案: <span class="your-answer">未作答</span> <i class="fas fa-times-circle explanation-icon" style="color: #dc3545;"></i> (错误)<br>`;
                        explanationContent += `正确答案: <span class="correct-answer">${correctAnswer}. ${choices[correctAnswer]}</span><br>`;
                    }
                } else if (questionType === 'multi-choice') {
                    const userAnsDisplay = (userAnswer && userAnswer.length > 0) ? 
                        userAnswer.map(ans => `${ans}. ${choices[ans]}`).join(', ') : '未作答';
                    // Ensure correctAnswer is an array for multi-choice for display consistency
                    const correctAnsArray = Array.isArray(correctAnswer) ? correctAnswer : (correctAnswer ? [correctAnswer] : []);
                    const correctAnsDisplay = (correctAnsArray.length > 0) ?
                        correctAnsArray.map(ans => `${ans}. ${choices[ans]}`).join(', ') : '无';

                    explanationContent += `你的答案: <span class="your-answer">${userAnsDisplay}</span> `;
                    explanationContent += isCorrect ? `<i class="fas fa-check-circle explanation-icon" style="color: #28a745;"></i> (正确)<br>` : `<i class="fas fa-times-circle explanation-icon" style="color: #dc3545;"></i> (错误)<br>`;
                    if (!isCorrect) {
                        explanationContent += `正确答案: <span class="correct-answer">${correctAnsDisplay}</span><br>`;
                    }
                } else if (questionType === 'fill-in-blank') {
                    // For fill-in-blank, explanation is handled in handleSubmitReattempt
                    // This branch might not be hit if explanation is built entirely in submit
                    console.warn("displayExplanation for fill-in-blank might be redundant here.");
                }
                // Matching explanation is handled within handleSubmitReattempt directly

                if (questionType !== 'fill-in-blank' && questionType !== 'matching') { // Only apply if not handled elsewhere
                    explanationContent += `<span class="explanation-text">解析: ${explanationText}</span></div>`;
                    questionExplanationDiv.innerHTML = explanationContent;
                    questionExplanationDiv.style.display = 'block';
                }
            }


            /**
             * Applies the visual state for a previously submitted quiz.
             */
            applySubmittedState() {
                this.quizSubmitted = true;
                this.startQuizBtn.disabled = true;
                this.submitQuizBtn.disabled = false; // Enable for re-attempt
                this.submitQuizBtn.textContent = '重新作答';
                this.disableOptions(); // Ensure options are disabled for viewing results

                const currentQuiz = quizData.questions[this.currentQuizIndex];
                const savedScore = this.quizScores[currentQuiz.id];

                if (savedScore) {
                    this.scoreDisplay.textContent = `正确率: ${savedScore.correct}/${savedScore.total} (${savedScore.percentage}%)`;
                    this.timerDisplay.textContent = savedScore.time;
                    this.userAnswers = savedScore.userAnswers || {}; // Restore user answers

                    this.quizContentElement.querySelectorAll('.question-num-in-text').forEach(span => {
                        span.classList.remove('highlighted-question-num');
                    });

                    // Re-evaluate and display explanations based on saved answers
                    switch (currentQuiz.questionType) {
                        case 'single-choice':
                        case 'true-false':
                            currentQuiz.options.forEach((optionData, optionIndex) => {
                                const questionBlockDiv = this.optionsContainer.querySelector(`.question-block[data-question-index="${optionIndex}"]`);
                                const correctAnswer = optionData.answer;
                                const userAnswer = this.userAnswers[optionIndex];
                                
                                let isCorrect = (userAnswer !== undefined && String(userAnswer) === String(correctAnswer));

                                questionBlockDiv.querySelectorAll('.choice-item').forEach(choiceElement => {
                                    const choiceKey = choiceElement.dataset.choice;
                                    choiceElement.classList.remove('selected-choice', 'correct-choice', 'incorrect-choice');

                                    if (String(choiceKey) === String(correctAnswer)) {
                                        choiceElement.classList.add('correct-choice');
                                    }
                                    if (userAnswer !== undefined && String(userAnswer) === String(choiceKey) && !isCorrect) {
                                        choiceElement.classList.add('incorrect-choice');
                                    }
                                });
                                this.displayExplanation(questionBlockDiv, userAnswer, correctAnswer, optionData.explanation, optionData.choices, isCorrect, currentQuiz.questionType);
                            });
                            break;

                        case 'multi-choice':
                            currentQuiz.options.forEach((optionData, optionIndex) => {
                                const questionBlockDiv = this.optionsContainer.querySelector(`.question-block[data-question-index="${optionIndex}"]`);
                                const correctAnswers = Array.isArray(optionData.answer) ? optionData.answer.sort() : [];
                                const userAnswers = (this.userAnswers[optionIndex] || []).sort();
                                
                                let isCorrect = (correctAnswers.length === userAnswers.length &&
                                                 correctAnswers.every((val, idx) => val === userAnswers[idx]));

                                questionBlockDiv.querySelectorAll('.choice-item').forEach(choiceElement => {
                                    const choiceKey = choiceElement.dataset.choice;
                                    choiceElement.classList.remove('selected-choice', 'correct-choice', 'incorrect-choice');

                                    if (correctAnswers.includes(choiceKey)) {
                                        choiceElement.classList.add('correct-choice');
                                    }
                                    if (userAnswers.includes(choiceKey) && !correctAnswers.includes(choiceKey)) {
                                        choiceElement.classList.add('incorrect-choice');
                                    }
                                });
                                this.displayExplanation(questionBlockDiv, userAnswer, correctAnswer, optionData.explanation, optionData.choices, isCorrect, currentQuiz.questionType);
                            });
                            break;

                        case 'fill-in-blank':
                            const fillInBlankOptionData = currentQuiz.options[0];
                            const fillInBlankQuestionBlockDiv = this.optionsContainer.querySelector(`.question-block[data-question-index="0"]`);
                            const correctAnswersArray = fillInBlankOptionData.answer;
                            const userInputsArray = this.userAnswers[0] || new Array(fillInBlankOptionData.blankCount).fill(''); // Restore user's answer array

                            let fillInBlankExplanationContent = `<div class="explanation-item">`;
                            
                            for (let i = 0; i < fillInBlankOptionData.blankCount; i++) {
                                const inputElement = fillInBlankQuestionBlockDiv.querySelector(`.fill-in-blank-input[data-blank-index="${i}"]`);
                                const correctAnswer = (correctAnswersArray[i] || '').toLowerCase().trim();
                                const userInput = (userInputsArray[i] || '').toLowerCase().trim();
                                
                                const isBlankCorrect = (userInput === correctAnswer);

                                inputElement.value = userInputsArray[i] || ''; // Display user's saved input
                                inputElement.disabled = true;
                                inputElement.classList.add('disabled');
                                inputElement.classList.remove('correct', 'incorrect'); // Clear previous visual states before applying new ones
                                
                                if (isBlankCorrect) {
                                    inputElement.classList.add('correct');
                                } else {
                                    inputElement.classList.add('incorrect');
                                }

                                fillInBlankExplanationContent += `<p>填空 ${i + 1}: `;
                                fillInBlankExplanationContent += `你的答案: <span class="your-answer">${userInputsArray[i] || '未作答'}</span> `;
                                fillInBlankExplanationContent += isBlankCorrect ? `<i class="fas fa-check-circle explanation-icon" style="color: #28a745;"></i> (正确)<br>` : `<i class="fas fa-times-circle explanation-icon" style="color: #dc3545;"></i> (错误)<br>`;
                                if (!isBlankCorrect) {
                                    fillInBlankExplanationContent += `正确答案: <span class="correct-answer">${correctAnswersArray[i]}</span><br>`;
                                }
                                fillInBlankExplanationContent += `</p>`;
                            }
                            fillInBlankExplanationContent += `<span class="explanation-text">解析: ${fillInBlankOptionData.explanation}</span></div>`;
                            fillInBlankQuestionBlockDiv.querySelector('.question-explanation').innerHTML = fillInBlankExplanationContent;
                            fillInBlankQuestionBlockDiv.querySelector('.question-explanation').style.display = 'block';
                            break;

                        case 'matching':
                            const optionData = currentQuiz.options[0];
                            const matchingQuestionBlockDiv = this.optionsContainer.querySelector(`.question-block[data-question-index="0"]`);
                            
                            matchingQuestionBlockDiv.querySelectorAll('.matching-item').forEach(item => {
                                item.classList.add('disabled');
                                item.style.pointerEvents = 'none';
                                item.classList.remove('matching-selected-left', 'matching-selected-right', 'dragging', 'drag-over'); // Clear any dragging/selection states
                            });
                            // Hide the user pairs display area during review
                            matchingQuestionBlockDiv.querySelector('.matching-user-pairs-display').style.display = 'none';


                            const correctMappings = optionData.answer;
                            const userMappings = this.userAnswers[0] || {};
                            let matchingExplanationContent = `<div class="explanation-item"><h4>连线结果：</h4>`;

                            for (const leftKey in correctMappings) {
                                const expectedRight = correctMappings[leftKey];
                                const userRight = userMappings[leftKey];
                                
                                const isPairCorrect = (userRight !== undefined && userRight === expectedRight);

                                const leftElem = matchingQuestionBlockDiv.querySelector(`.left-item[data-value="${leftKey}"]`);
                                const userRightElem = matchingQuestionBlockDiv.querySelector(`.right-item[data-value="${userRight}"]`); // User's chosen right
                                const correctRightElem = matchingQuestionBlockDiv.querySelector(`.right-item[data-value="${expectedRight}"]`); // Actual correct right

                                if (isPairCorrect) {
                                    if (leftElem) leftElem.classList.add('matching-connected');
                                    if (userRightElem) userRightElem.classList.add('matching-connected');
                                } else {
                                    if (leftElem) leftElem.classList.add('matching-incorrect');
                                    if (userRightElem && userRight) userRightElem.classList.add('matching-incorrect');
                                    if (correctRightElem) correctRightElem.classList.add('correct-choice');
                                }

                                matchingExplanationContent += `<div class="matching-explanation-pair ${isPairCorrect ? 'correct' : 'incorrect'}">
                                    <span class="left-side">${leftKey}</span>
                                    <i class="fas ${isPairCorrect ? 'fa-check-circle' : 'fa-times-circle'}" style="color: ${isPairCorrect ? '#28a745' : '#dc3545'}; margin: 0 5px;"></i>
                                    <span class="right-side">${userRight || '未作答'} (正确: ${expectedRight})</span>
                                </div>`;
                            }
                            matchingExplanationContent += `<span class="explanation-text">解析: ${optionData.explanation}</span></div>`;
                            matchingQuestionBlockDiv.querySelector('.question-explanation').innerHTML = matchingExplanationContent;
                            matchingQuestionBlockDiv.querySelector('.question-explanation').style.display = 'block';
                            break;
                    }
                }
            }

            /**
             * Displays the explanation for a given question block.
             * @param {HTMLElement} questionBlockDiv - The question block DOM element.
             * @param {*} userAnswer - The user's answer (string, array, or object).
             * @param {*} correctAnswer - The correct answer (string, array, or object).
             * @param {string} explanationText - The full explanation text.
             * @param {object} choices - The choices object (for choice-based questions).
             * @param {boolean} isCorrect - Whether the user's answer was correct.
             * @param {string} questionType - The type of question.
             */
            displayExplanation(questionBlockDiv, userAnswer, correctAnswer, explanationText, choices, isCorrect, questionType) {
                const questionExplanationDiv = questionBlockDiv.querySelector('.question-explanation');
                let explanationContent = `<div class="explanation-item">`;

                if (questionType === 'single-choice' || questionType === 'true-false') {
                    if (userAnswer !== undefined && choices && choices[userAnswer]) {
                        explanationContent += `你的答案: <span class="your-answer">${userAnswer}. ${choices[userAnswer]}</span> `;
                        explanationContent += isCorrect ? `<i class="fas fa-check-circle explanation-icon" style="color: #28a745;"></i> (正确)<br>` : `<i class="fas fa-times-circle explanation-icon" style="color: #dc3545;"></i> (错误)<br>`;
                        if (!isCorrect) {
                            explanationContent += `正确答案: <span class="correct-answer">${correctAnswer}. ${choices[correctAnswer]}</span><br>`;
                        }
                    } else {
                        explanationContent += `你的答案: <span class="your-answer">未作答</span> <i class="fas fa-times-circle explanation-icon" style="color: #dc3545;"></i> (错误)<br>`;
                        explanationContent += `正确答案: <span class="correct-answer">${correctAnswer}. ${choices[correctAnswer]}</span><br>`;
                    }
                } else if (questionType === 'multi-choice') {
                    const userAnsDisplay = (userAnswer && userAnswer.length > 0) ? 
                        userAnswer.map(ans => `${ans}. ${choices[ans]}`).join(', ') : '未作答';
                    // Ensure correctAnswer is an array for multi-choice for display consistency
                    const correctAnsArray = Array.isArray(correctAnswer) ? correctAnswer : (correctAnswer ? [correctAnswer] : []);
                    const correctAnsDisplay = (correctAnsArray.length > 0) ?
                        correctAnsArray.map(ans => `${ans}. ${choices[ans]}`).join(', ') : '无';

                    explanationContent += `你的答案: <span class="your-answer">${userAnsDisplay}</span> `;
                    explanationContent += isCorrect ? `<i class="fas fa-check-circle explanation-icon" style="color: #28a745;"></i> (正确)<br>` : `<i class="fas fa-times-circle explanation-icon" style="color: #dc3545;"></i> (错误)<br>`;
                    if (!isCorrect) {
                        explanationContent += `正确答案: <span class="correct-answer">${correctAnsDisplay}</span><br>`;
                    }
                } else if (questionType === 'fill-in-blank') {
                    // For fill-in-blank, explanation is handled in handleSubmitReattempt
                    // This branch might not be hit if explanation is built entirely in submit
                    console.warn("displayExplanation for fill-in-blank might be redundant here.");
                }
                // Matching explanation is handled within handleSubmitReattempt directly

                if (questionType !== 'fill-in-blank' && questionType !== 'matching') { // Only apply if not handled elsewhere
                    explanationContent += `<span class="explanation-text">解析: ${explanationText}</span></div>`;
                    questionExplanationDiv.innerHTML = explanationContent;
                    questionExplanationDiv.style.display = 'block';
                }
            }


            /**
             * Applies the visual state for a previously submitted quiz.
             */
            applySubmittedState() {
                this.quizSubmitted = true;
                this.startQuizBtn.disabled = true;
                this.submitQuizBtn.disabled = false; // Enable for re-attempt
                this.submitQuizBtn.textContent = '重新作答';
                this.disableOptions(); // Ensure options are disabled for viewing results

                const currentQuiz = quizData.questions[this.currentQuizIndex];
                const savedScore = this.quizScores[currentQuiz.id];

                if (savedScore) {
                    this.scoreDisplay.textContent = `正确率: ${savedScore.correct}/${savedScore.total} (${savedScore.percentage}%)`;
                    this.timerDisplay.textContent = savedScore.time;
                    this.userAnswers = savedScore.userAnswers || {}; // Restore user answers

                    this.quizContentElement.querySelectorAll('.question-num-in-text').forEach(span => {
                        span.classList.remove('highlighted-question-num');
                    });

                    // Re-evaluate and display explanations based on saved answers
                    switch (currentQuiz.questionType) {
                        case 'single-choice':
                        case 'true-false':
                            currentQuiz.options.forEach((optionData, optionIndex) => {
                                const questionBlockDiv = this.optionsContainer.querySelector(`.question-block[data-question-index="${optionIndex}"]`);
                                const correctAnswer = optionData.answer;
                                const userAnswer = this.userAnswers[optionIndex];
                                
                                let isCorrect = (userAnswer !== undefined && String(userAnswer) === String(correctAnswer));

                                questionBlockDiv.querySelectorAll('.choice-item').forEach(choiceElement => {
                                    const choiceKey = choiceElement.dataset.choice;
                                    choiceElement.classList.remove('selected-choice', 'correct-choice', 'incorrect-choice');

                                    if (String(choiceKey) === String(correctAnswer)) {
                                        choiceElement.classList.add('correct-choice');
                                    }
                                    if (userAnswer !== undefined && String(userAnswer) === String(choiceKey) && !isCorrect) {
                                        choiceElement.classList.add('incorrect-choice');
                                    }
                                });
                                this.displayExplanation(questionBlockDiv, userAnswer, correctAnswer, optionData.explanation, optionData.choices, isCorrect, currentQuiz.questionType);
                            });
                            break;

                        case 'multi-choice':
                            currentQuiz.options.forEach((optionData, optionIndex) => {
                                const questionBlockDiv = this.optionsContainer.querySelector(`.question-block[data-question-index="${optionIndex}"]`);
                                const correctAnswers = Array.isArray(optionData.answer) ? optionData.answer.sort() : [];
                                const userAnswers = (this.userAnswers[optionIndex] || []).sort();
                                
                                let isCorrect = (correctAnswers.length === userAnswers.length &&
                                                 correctAnswers.every((val, idx) => val === userAnswers[idx]));

                                questionBlockDiv.querySelectorAll('.choice-item').forEach(choiceElement => {
                                    const choiceKey = choiceElement.dataset.choice;
                                    choiceElement.classList.remove('selected-choice', 'correct-choice', 'incorrect-choice');

                                    if (correctAnswers.includes(choiceKey)) {
                                        choiceElement.classList.add('correct-choice');
                                    }
                                    if (userAnswers.includes(choiceKey) && !correctAnswers.includes(choiceKey)) {
                                        choiceItem.classList.add('incorrect-choice');
                                    }
                                });
                                this.displayExplanation(questionBlockDiv, userAnswer, correctAnswer, optionData.explanation, optionData.choices, isCorrect, currentQuiz.questionType);
                            });
                            break;

                        case 'fill-in-blank':
                            const fillInBlankOptionData = currentQuiz.options[0];
                            const fillInBlankQuestionBlockDiv = this.optionsContainer.querySelector(`.question-block[data-question-index="0"]`);
                            const correctAnswersArray = fillInBlankOptionData.answer;
                            const userInputsArray = this.userAnswers[0] || new Array(fillInBlankOptionData.blankCount).fill(''); // Restore user's answer array

                            let fillInBlankExplanationContent = `<div class="explanation-item">`;
                            
                            for (let i = 0; i < fillInBlankOptionData.blankCount; i++) {
                                const inputElement = fillInBlankQuestionBlockDiv.querySelector(`.fill-in-blank-input[data-blank-index="${i}"]`);
                                const correctAnswer = (correctAnswersArray[i] || '').toLowerCase().trim();
                                const userInput = (userInputsArray[i] || '').toLowerCase().trim();
                                
                                const isBlankCorrect = (userInput === correctAnswer);

                                inputElement.value = userInputsArray[i] || ''; // Display user's saved input
                                inputElement.disabled = true;
                                inputElement.classList.add('disabled');
                                inputElement.classList.remove('correct', 'incorrect'); // Clear previous visual states before applying new ones
                                
                                if (isBlankCorrect) {
                                    inputElement.classList.add('correct');
                                } else {
                                    inputElement.classList.add('incorrect');
                                }

                                fillInBlankExplanationContent += `<p>填空 ${i + 1}: `;
                                fillInBlankExplanationContent += `你的答案: <span class="your-answer">${userInputsArray[i] || '未作答'}</span> `;
                                fillInBlankExplanationContent += isBlankCorrect ? `<i class="fas fa-check-circle explanation-icon" style="color: #28a745;"></i> (正确)<br>` : `<i class="fas fa-times-circle explanation-icon" style="color: #dc3545;"></i> (错误)<br>`;
                                if (!isBlankCorrect) {
                                    fillInBlankExplanationContent += `正确答案: <span class="correct-answer">${correctAnswersArray[i]}</span><br>`;
                                }
                                fillInBlankExplanationContent += `</p>`;
                            }
                            fillInBlankExplanationContent += `<span class="explanation-text">解析: ${fillInBlankOptionData.explanation}</span></div>`;
                            fillInBlankQuestionBlockDiv.querySelector('.question-explanation').innerHTML = fillInBlankExplanationContent;
                            fillInBlankQuestionBlockDiv.querySelector('.question-explanation').style.display = 'block';
                            break;

                        case 'matching':
                            const optionData = currentQuiz.options[0];
                            const matchingQuestionBlockDiv = this.optionsContainer.querySelector(`.question-block[data-question-index="0"]`);
                            
                            // Re-enable user pairs display for review if it was hidden
                            matchingQuestionBlockDiv.querySelector('.matching-user-pairs-display').style.display = 'block';

                            matchingQuestionBlockDiv.querySelectorAll('.matching-item').forEach(item => {
                                item.classList.add('disabled');
                                item.style.pointerEvents = 'none';
                                item.classList.remove('matching-selected-left', 'matching-selected-right', 'dragging', 'drag-over'); // Clear any dragging/selection states
                            });

                            const correctMappings = optionData.answer;
                            const userMappings = this.userAnswers[0] || {};
                            let matchingExplanationContent = `<div class="explanation-item"><h4>连线结果：</h4>`;

                            // Re-render the user pairs display with correct/incorrect visual feedback
                            const matchedPairsList = matchingQuestionBlockDiv.querySelector('#matched-pairs-list');
                            if (matchedPairsList) {
                                matchedPairsList.innerHTML = ''; // Clear existing
                                const allLeftItems = currentQuiz.options[0].pairs.map(p => p.left);

                                allLeftItems.forEach(leftKey => {
                                    const expectedRight = correctMappings[leftKey];
                                    const userRight = userMappings[leftKey];
                                    const isPairCorrect = (userRight !== undefined && userRight === expectedRight);

                                    const pairDisplay = document.createElement('div');
                                    pairDisplay.classList.add('matched-pair-item-display');
                                    pairDisplay.classList.add(isPairCorrect ? 'correct' : 'incorrect'); // Add class for styling feedback
                                    pairDisplay.style.position = 'static'; // Remove absolute positioning for the button
                                    pairDisplay.style.paddingRight = '12px'; // Adjust padding since no remove button

                                    pairDisplay.innerHTML = `
                                        <span class="left-display">${leftKey}</span>
                                        <i class="fas ${isPairCorrect ? 'fa-check-circle' : 'fa-times-circle'}" style="color: ${isPairCorrect ? '#28a745' : '#dc3545'}; margin: 0 5px;"></i>
                                        <span class="right-display">${userRight || '未作答'} (正确: ${expectedRight})</span>
                                    `;
                                    matchedPairsList.appendChild(pairDisplay);

                                    // Apply visual feedback to original items as well
                                    const leftElem = matchingQuestionBlockDiv.querySelector(`.left-item[data-value="${leftKey}"]`);
                                    const userRightElem = matchingQuestionBlockDiv.querySelector(`.right-item[data-value="${userRight}"]`);
                                    const correctRightElem = matchingQuestionBlockDiv.querySelector(`.right-item[data-value="${expectedRight}"]`);

                                    if (isPairCorrect) {
                                        if (leftElem) leftElem.classList.add('matching-connected');
                                        if (userRightElem) userRightElem.classList.add('matching-connected');
                                    } else {
                                        if (leftElem) leftElem.classList.add('matching-incorrect');
                                        if (userRightElem && userRight) userRightElem.classList.add('matching-incorrect');
                                        if (correctRightElem) correctRightElem.classList.add('correct-choice');
                                    }
                                });
                            }


                            matchingExplanationContent += `<span class="explanation-text">解析: ${optionData.explanation}</span></div>`;
                            matchingQuestionBlockDiv.querySelector('.question-explanation').innerHTML = matchingExplanationContent;
                            matchingQuestionBlockDiv.querySelector('.question-explanation').style.display = 'block';
                            break;
                    }
                }
            }

            /**
             * Displays the explanation for a given question block.
             * @param {HTMLElement} questionBlockDiv - The question block DOM element.
             * @param {*} userAnswer - The user's answer (string, array, or object).
             * @param {*} correctAnswer - The correct answer (string, array, or object).
             * @param {string} explanationText - The full explanation text.
             * @param {object} choices - The choices object (for choice-based questions).
             * @param {boolean} isCorrect - Whether the user's answer was correct.
             * @param {string} questionType - The type of question.
             */
            displayExplanation(questionBlockDiv, userAnswer, correctAnswer, explanationText, choices, isCorrect, questionType) {
                const questionExplanationDiv = questionBlockDiv.querySelector('.question-explanation');
                let explanationContent = `<div class="explanation-item">`;

                if (questionType === 'single-choice' || questionType === 'true-false') {
                    if (userAnswer !== undefined && choices && choices[userAnswer]) {
                        explanationContent += `你的答案: <span class="your-answer">${userAnswer}. ${choices[userAnswer]}</span> `;
                        explanationContent += isCorrect ? `<i class="fas fa-check-circle explanation-icon" style="color: #28a745;"></i> (正确)<br>` : `<i class="fas fa-times-circle explanation-icon" style="color: #dc3545;"></i> (错误)<br>`;
                        if (!isCorrect) {
                            explanationContent += `正确答案: <span class="correct-answer">${correctAnswer}. ${choices[correctAnswer]}</span><br>`;
                        }
                    } else {
                        explanationContent += `你的答案: <span class="your-answer">未作答</span> <i class="fas fa-times-circle explanation-icon" style="color: #dc3545;"></i> (错误)<br>`;
                        explanationContent += `正确答案: <span class="correct-answer">${correctAnswer}. ${choices[correctAnswer]}</span><br>`;
                    }
                } else if (questionType === 'multi-choice') {
                    const userAnsDisplay = (userAnswer && userAnswer.length > 0) ? 
                        userAnswer.map(ans => `${ans}. ${choices[ans]}`).join(', ') : '未作答';
                    // Ensure correctAnswer is an array for multi-choice for display consistency
                    const correctAnsArray = Array.isArray(correctAnswer) ? correctAnswer : (correctAnswer ? [correctAnswer] : []);
                    const correctAnsDisplay = (correctAnsArray.length > 0) ?
                        correctAnsArray.map(ans => `${ans}. ${choices[ans]}`).join(', ') : '无';

                    explanationContent += `你的答案: <span class="your-answer">${userAnsDisplay}</span> `;
                    explanationContent += isCorrect ? `<i class="fas fa-check-circle explanation-icon" style="color: #28a745;"></i> (正确)<br>` : `<i class="fas fa-times-circle explanation-icon" style="color: #dc3545;"></i> (错误)<br>`;
                    if (!isCorrect) {
                        explanationContent += `正确答案: <span class="correct-answer">${correctAnsDisplay}</span><br>`;
                    }
                } else if (questionType === 'fill-in-blank') {
                    // For fill-in-blank, explanation is handled in handleSubmitReattempt
                    // This branch might not be hit if explanation is built entirely in submit
                    console.warn("displayExplanation for fill-in-blank might be redundant here.");
                }
                // Matching explanation is handled within handleSubmitReattempt directly

                if (questionType !== 'fill-in-blank' && questionType !== 'matching') { // Only apply if not handled elsewhere
                    explanationContent += `<span class="explanation-text">解析: ${explanationText}</span></div>`;
                    questionExplanationDiv.innerHTML = explanationContent;
                    questionExplanationDiv.style.display = 'block';
                }
            }


            /**
             * Applies the visual state for a previously submitted quiz.
             */
            applySubmittedState() {
                this.quizSubmitted = true;
                this.startQuizBtn.disabled = true;
                this.submitQuizBtn.disabled = false; // Enable for re-attempt
                this.submitQuizBtn.textContent = '重新作答';
                this.disableOptions(); // Ensure options are disabled for viewing results

                const currentQuiz = quizData.questions[this.currentQuizIndex];
                const savedScore = this.quizScores[currentQuiz.id];

                if (savedScore) {
                    this.scoreDisplay.textContent = `正确率: ${savedScore.correct}/${savedScore.total} (${savedScore.percentage}%)`;
                    this.timerDisplay.textContent = savedScore.time;
                    this.userAnswers = savedScore.userAnswers || {}; // Restore user answers

                    this.quizContentElement.querySelectorAll('.question-num-in-text').forEach(span => {
                        span.classList.remove('highlighted-question-num');
                    });

                    // Re-evaluate and display explanations based on saved answers
                    switch (currentQuiz.questionType) {
                        case 'single-choice':
                        case 'true-false':
                            currentQuiz.options.forEach((optionData, optionIndex) => {
                                const questionBlockDiv = this.optionsContainer.querySelector(`.question-block[data-question-index="${optionIndex}"]`);
                                const correctAnswer = optionData.answer;
                                const userAnswer = this.userAnswers[optionIndex];
                                
                                let isCorrect = (userAnswer !== undefined && String(userAnswer) === String(correctAnswer));

                                questionBlockDiv.querySelectorAll('.choice-item').forEach(choiceElement => {
                                    const choiceKey = choiceElement.dataset.choice;
                                    choiceElement.classList.remove('selected-choice', 'correct-choice', 'incorrect-choice');

                                    if (String(choiceKey) === String(correctAnswer)) {
                                        choiceElement.classList.add('correct-choice');
                                    }
                                    if (userAnswer !== undefined && String(userAnswer) === String(choiceKey) && !isCorrect) {
                                        choiceElement.classList.add('incorrect-choice');
                                    }
                                });
                                this.displayExplanation(questionBlockDiv, userAnswer, correctAnswer, optionData.explanation, optionData.choices, isCorrect, currentQuiz.questionType);
                            });
                            break;

                        case 'multi-choice':
                            currentQuiz.options.forEach((optionData, optionIndex) => {
                                const questionBlockDiv = this.optionsContainer.querySelector(`.question-block[data-question-index="${optionIndex}"]`);
                                const correctAnswers = Array.isArray(optionData.answer) ? optionData.answer.sort() : [];
                                const userAnswers = (this.userAnswers[optionIndex] || []).sort();
                                
                                let isCorrect = (correctAnswers.length === userAnswers.length &&
                                                 correctAnswers.every((val, idx) => val === userAnswers[idx]));

                                questionBlockDiv.querySelectorAll('.choice-item').forEach(choiceElement => {
                                    const choiceKey = choiceElement.dataset.choice;
                                    choiceElement.classList.remove('selected-choice', 'correct-choice', 'incorrect-choice');

                                    if (correctAnswers.includes(choiceKey)) {
                                        choiceElement.classList.add('correct-choice');
                                    }
                                    if (userAnswers.includes(choiceKey) && !correctAnswers.includes(choiceKey)) {
                                        choiceItem.classList.add('incorrect-choice');
                                    }
                                });
                                this.displayExplanation(questionBlockDiv, userAnswer, correctAnswer, optionData.explanation, optionData.choices, isCorrect, currentQuiz.questionType);
                            });
                            break;

                        case 'fill-in-blank':
                            const fillInBlankOptionData = currentQuiz.options[0];
                            const fillInBlankQuestionBlockDiv = this.optionsContainer.querySelector(`.question-block[data-question-index="0"]`);
                            const correctAnswersArray = fillInBlankOptionData.answer;
                            const userInputsArray = this.userAnswers[0] || new Array(fillInBlankOptionData.blankCount).fill(''); // Restore user's answer array

                            let fillInBlankExplanationContent = `<div class="explanation-item">`;
                            
                            for (let i = 0; i < fillInBlankOptionData.blankCount; i++) {
                                const inputElement = fillInBlankQuestionBlockDiv.querySelector(`.fill-in-blank-input[data-blank-index="${i}"]`);
                                const correctAnswer = (correctAnswersArray[i] || '').toLowerCase().trim();
                                const userInput = (userInputsArray[i] || '').toLowerCase().trim();
                                
                                const isBlankCorrect = (userInput === correctAnswer);

                                inputElement.value = userInputsArray[i] || ''; // Display user's saved input
                                inputElement.disabled = true;
                                inputElement.classList.add('disabled');
                                inputElement.classList.remove('correct', 'incorrect'); // Clear previous visual states before applying new ones
                                
                                if (isBlankCorrect) {
                                    inputElement.classList.add('correct');
                                } else {
                                    inputElement.classList.add('incorrect');
                                }

                                fillInBlankExplanationContent += `<p>填空 ${i + 1}: `;
                                fillInBlankExplanationContent += `你的答案: <span class="your-answer">${userInputsArray[i] || '未作答'}</span> `;
                                fillInBlankExplanationContent += isBlankCorrect ? `<i class="fas fa-check-circle explanation-icon" style="color: #28a745;"></i> (正确)<br>` : `<i class="fas fa-times-circle explanation-icon" style="color: #dc3545;"></i> (错误)<br>`;
                                if (!isBlankCorrect) {
                                    fillInBlankExplanationContent += `正确答案: <span class="correct-answer">${correctAnswersArray[i]}</span><br>`;
                                }
                                fillInBlankExplanationContent += `</p>`;
                            }
                            fillInBlankExplanationContent += `<span class="explanation-text">解析: ${fillInBlankOptionData.explanation}</span></div>`;
                            fillInBlankQuestionBlockDiv.querySelector('.question-explanation').innerHTML = fillInBlankExplanationContent;
                            fillInBlankQuestionBlockDiv.querySelector('.question-explanation').style.display = 'block';
                            break;

                        case 'matching':
                            const optionData = currentQuiz.options[0];
                            const matchingQuestionBlockDiv = this.optionsContainer.querySelector(`.question-block[data-question-index="0"]`);
                            
                            // Re-enable user pairs display for review if it was hidden
                            matchingQuestionBlockDiv.querySelector('.matching-user-pairs-display').style.display = 'block';

                            matchingQuestionBlockDiv.querySelectorAll('.matching-item').forEach(item => {
                                item.classList.add('disabled');
                                item.style.pointerEvents = 'none';
                                item.classList.remove('matching-selected-left', 'matching-selected-right', 'dragging', 'drag-over'); // Clear any dragging/selection states
                            });

                            const correctMappings = optionData.answer;
                            const userMappings = this.userAnswers[0] || {};
                            let matchingExplanationContent = `<div class="explanation-item"><h4>连线结果：</h4>`;

                            // Re-render the user pairs display with correct/incorrect visual feedback
                            const matchedPairsList = matchingQuestionBlockDiv.querySelector('#matched-pairs-list');
                            if (matchedPairsList) {
                                matchedPairsList.innerHTML = ''; // Clear existing
                                const allLeftItems = currentQuiz.options[0].pairs.map(p => p.left);

                                allLeftItems.forEach(leftKey => {
                                    const expectedRight = correctMappings[leftKey];
                                    const userRight = userMappings[leftKey];
                                    const isPairCorrect = (userRight !== undefined && userRight === expectedRight);

                                    const pairDisplay = document.createElement('div');
                                    pairDisplay.classList.add('matched-pair-item-display');
                                    pairDisplay.classList.add(isPairCorrect ? 'correct' : 'incorrect'); // Add class for styling feedback
                                    pairDisplay.style.position = 'static'; // Remove absolute positioning for the button
                                    pairDisplay.style.paddingRight = '12px'; // Adjust padding since no remove button

                                    pairDisplay.innerHTML = `
                                        <span class="left-display">${leftKey}</span>
                                        <i class="fas ${isPairCorrect ? 'fa-check-circle' : 'fa-times-circle'}" style="color: ${isPairCorrect ? '#28a745' : '#dc3545'}; margin: 0 5px;"></i>
                                        <span class="right-display">${userRight || '未作答'} (正确: ${expectedRight})</span>
                                    `;
                                    matchedPairsList.appendChild(pairDisplay);

                                    // Apply visual feedback to original items as well
                                    const leftElem = matchingQuestionBlockDiv.querySelector(`.left-item[data-value="${leftKey}"]`);
                                    const userRightElem = matchingQuestionBlockDiv.querySelector(`.right-item[data-value="${userRight}"]`);
                                    const correctRightElem = matchingQuestionBlockDiv.querySelector(`.right-item[data-value="${expectedRight}"]`);

                                    if (isPairCorrect) {
                                        if (leftElem) leftElem.classList.add('matching-connected');
                                        if (userRightElem) userRightElem.classList.add('matching-connected');
                                    } else {
                                        if (leftElem) leftElem.classList.add('matching-incorrect');
                                        if (userRightElem && userRight) userRightElem.classList.add('matching-incorrect');
                                        if (correctRightElem) correctRightElem.classList.add('correct-choice');
                                    }
                                });
                            }


                            matchingExplanationContent += `<span class="explanation-text">解析: ${optionData.explanation}</span></div>`;
                            matchingQuestionBlockDiv.querySelector('.question-explanation').innerHTML = matchingExplanationContent;
                            matchingQuestionBlockDiv.querySelector('.question-explanation').style.display = 'block';
                            break;
                    }
                }
            }

            /**
             * Helper function to escape special characters in a string for use in a RegExp.
             * @param {string} string - The string to escape.
             * @returns {string} The escaped string.
             */
            escapeRegExp(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            /**
             * Maps internal questionType to a human-readable Chinese string.
             * @param {string} type - The internal question type.
             * @returns {string} The Chinese translation.
             */
            mapQuestionTypeToChinese(type) {
                switch (type) {
                    case 'single-choice': return '单选题';
                    case 'multi-choice': return '多选题';
                    case 'fill-in-blank': return '填空题';
                    case 'matching': return '连线题';
                    case 'true-false': return '判断题';
                    default: return '未知题型';
                }
            }
        }

        // Initialize the QuizApp when the DOM is fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            const app = new QuizApp();
            app.init();
        });
    </script>
</body>
</html>
